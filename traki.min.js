/******/(()=>{// webpackBootstrap
/******/"use strict";
// UNUSED EXPORTS: traki
// ./src/constants/constants.ts
// Storage keys
const e=Object.freeze({API_KEY:"TRAKI_API_KEY",TRACE_ID:"TRAKI_TRACE_ID",CAMPAIGN_ID:"TRAKI_CAMPAIGN_ID",BASE_URL:"TRAKI_BASE_URL",SESSION_START:"TRAKI_SESSION_START",CHECKOUT_URL:"TRAKI_CHECKOUT_URL",UTM_SOURCE:"TRAKI_UTM_SOURCE",TTY_LVL:"TRAKI_TTY_LVL"}),t=Object.freeze({URL_PARAMS:"URL_PARAMS",SESSION_STORAGE:"SESSION_STORAGE",LOCAL_STORAGE:"LOCAL_STORAGE",THIS_SCRIPT:"THIS_SCRIPT"}),r="https://api.traki.io/",n={error:1,warn:2,log:3,info:4,debug:5,group:6,groupCollapsed:6,groupEnd:6,trace:7},o="utm_source",a=t,i={API_KEY:{storageKey:e.API_KEY,required:!0,availableSourcesSorted:[a.THIS_SCRIPT,a.SESSION_STORAGE,a.LOCAL_STORAGE],nameWords:["api","key"]},CAMPAIGN_ID:{storageKey:e.CAMPAIGN_ID,required:!0,availableSourcesSorted:[a.URL_PARAMS,a.SESSION_STORAGE,a.LOCAL_STORAGE,a.THIS_SCRIPT],nameWords:["campaign","id"]},BASE_URL:{storageKey:e.BASE_URL,defaultValue:r,availableSourcesSorted:[a.URL_PARAMS,a.SESSION_STORAGE,a.LOCAL_STORAGE,a.THIS_SCRIPT],nameWords:["base","url"]},TRACE_ID:{storageKey:e.TRACE_ID,defaultValue:"",availableSourcesSorted:[a.URL_PARAMS,a.SESSION_STORAGE,a.LOCAL_STORAGE],nameWords:["trace","id"]},TTY_LEVEL:{storageKey:"",defaultValue:"none",availableSourcesSorted:[a.URL_PARAMS,a.SESSION_STORAGE,a.LOCAL_STORAGE,a.THIS_SCRIPT],nameWords:["tty","lvl"]},CHECKOUT_URL:{storageKey:e.CHECKOUT_URL,defaultValue:"https://pay.gamestickkwai.shop/n1NLgwJDyYVGMxE",availableSourcesSorted:[a.THIS_SCRIPT,a.SESSION_STORAGE,a.LOCAL_STORAGE],nameWords:["checkout","url"]}};
/**
 * External Input Params Sources
 * Define the name of the possible sources to look for the EIPs (External Input Sources).
 *
 * Ex.:
 * The CAMPAIGN_ID might be stored in the SESSION_STORAGE.
 * The TRACE_ID might be provided via URL_PARAMS.
 * The BASE_URL could be set as an attribute of THIS_SCRIPT.
 *
 * The {EIP}'s value is probably defined in an {EIP Source}.
 * The {EIP} must be defined in at least one of the {EIP Sources}.
 *
 * This just names the External Input Param Sources.
 * They are used elsewhere as the keys of an object who assigns functions to them, defining then how exacly these Sources are queried for the EIP values.
 */ // ./src/functions/storage.ts
function c(e){const t=this;return{get:()=>t.get(e),set:r=>t.set(e,r),keys:()=>Object.keys(t)}}function s(e){return{context:c,get:t=>e.getItem(t)??void 0,set(t,r){e.setItem(t,r)},keys:()=>Object.keys(e)}}const u={local:s(localStorage),session:s(sessionStorage)};
/**
 * Validation error class
 */
class l extends Error{field;value;constructor(e,t,r){super(e),this.field=t,this.value=r,this.name="ValidationError"}}
/**
 * Validates required fields are present and non-empty
 */const d=(e,t)=>{if(!e||"string"==typeof e&&""===e.trim())throw new l(`${t} is required`,t,e)};
/**
 * Validates UUID fields
 */
/**
 * Simpler way to validate several properties of an object
 * @param subject Object to validate the properties from
 * @param spec Tuple of propertyName and validator function
 * @returns true for all valid, false if any prop fails validation
 */
function g(e,t){let r={valid:!0,fields:[]};return t.forEach(([t,n])=>{try{n(e[t],String(t))}catch(n){r.valid=!1,n instanceof l?r.fields.push({field:n.field,value:n.value,msg:n.message}):r.fields.push({field:String(t),value:e[t],msg:`Unknown error when validating ${String(t)}`})}}),r}// ./src/functions/URLSearchParamsWrapped.ts
function f(e=""){let t={},r=e;if(!r)try{r=location.search}catch(e){r=""}function n(e){t=function(e){const t={},r=e.startsWith("?")?e.slice(1):e;if(!r)return t;for(let e of r.split("&"))if(e.includes("=")){const[r,a]=e.split("=").map(e=>{try{return decodeURIComponent(e)}catch(e){return""}}),i=r.endsWith("[]"),c=a.includes(",")&&!i;n(t,i?r.slice(0,-2):r,c?a.split(",").map(o):o(a))}else{n(t,decodeURIComponent(e),!0)}return t;function n(e,t,r){if(void 0!==r){if(null!==r)return Array.isArray(r)?(e[t]||(e[t]=[]),void e[t].push(...r)):void(void 0===e[t]?e[t]=r:Array.isArray(e[t])?e[t].push(r):e[t]=[e[t],r]);e[t]=null}}function o(e){const t=e.toLowerCase();return""===t||"null"===t?null:"undefined"!==t?"true"===t||"false"!==t&&(!isNaN(Number(t))&&Number.isFinite(+t)&&""!==t.trim()?Number(t):t):void 0}}(e)}function o(){return Object.entries(t).map(([e,t])=>{const r=encodeURIComponent(e);return Array.isArray(t)&&t?.length>0?t.map(e=>`${r}=${encodeURIComponent(String(e))}`).join("&"):!!t&&`${r}=${encodeURIComponent(String(t))}`}).filter(Boolean).join("&")}return n(r),new Proxy({},{get:(e,r)=>"load"===r?n:r===Symbol.toPrimitive?()=>o():"toString"===r?o:r in t?t[r]:void 0,set:(e,r,n)=>(t[r]=n,!0)})}// ./src/functions/currentScript.ts
const h=Object.values(i).map(e=>e.nameWords);let p=null;function m(e){if(!e)return!1;const t=C(e);if(Object.keys(t).length<1)return!1;return h.map(e=>N(e,t)).filter(Boolean).length>=2}function S(){const e=function(){const e=[document.currentScript,...document.querySelectorAll(`script[src*="${r}"]`),...Array.from(document.scripts).filter(e=>e.src.includes("traki"))],t=new Set,n=[];return e.forEach(e=>{e instanceof HTMLScriptElement&&(t.has(e)||(t.add(e),n.push(e)))}),n}();for(const t of e)if(m(t))return t;return e[0]??null}// ./src/functions/utmSourceManager.ts
function y(e){if(!e)throw new Error(`getFinalURL: invalid argument inputURL with value "${e}"`);let t=Boolean(e)?e instanceof URL?e.toString():String(e):"";const r=R.getUtmSource();
// trkiout.trace(`getFinalURL: will append in "${inputURL}" the utm "${utmSourceVal}"`)
if(!function(e){try{if(!e)return!1;if("#"===e.charAt(0))return!1;if(/^\s*javascript:/i.test(e))return!1;const t=new URL(e,location.href);return!!/^https?:$/i.test(t.protocol)}catch(e){return!1}}(t))
// trkiout.trace(`Trying to add UTM source to invalid URL '${strURL}'`);
return"";const n=new URL(t,location.href);return r?(n.searchParams.set(o,r),n.toString()):(T.error("Failed to append UTM Source to URL"),T.log(`Original URL was '${e}'`),n.toString())}
/**
 * Parses utm_source from URL and extracts trace_id and api_key
 * Expected format: {trace_id}::{api_key}
 * Example: 1953adf5-9f26-4740-ae7f-1d883e0fb674::tk_MhPRG01K_01K9gT5WSR0dJZhyNQJZ0BRCmw
 */ // ./src/functions/inputSourceSelect.ts
const _={[t.URL_PARAMS]:{
// getParamValue: (() => {
//   // TODO: deduplicate "getUrlParameters" function and use siungle utility source
//   const urlParams = Object.fromEntries(new URLSearchParams(window.location.search));
//   return function getParamValue(paramName: string) {
//     let r = urlParams[paramName];
//     if (!r) return null;
//     if (r) r = decodeURIComponent(r);
//     return r;
//   }
// })(),
allSourceParams:()=>f()},[t.SESSION_STORAGE]:{
// getParamValue: (() => {
//   return function getParamValue(paramName: string) {
//     const r = stores.session.get(paramName);
//     return r ? String(r) : null;
//   }
// })(),
allSourceParams:()=>u.session.keys().reduce((e,t)=>({...e,[t]:u.session.get(t)}),{})},[t.LOCAL_STORAGE]:{
// getParamValue: (() => {
//   return function getParamValue(paramName: string) {
//     const r = stores.local.get(paramName);
//     return r ? String(r) : null;
//   }
// })(),
allSourceParams:()=>u.local.keys().reduce((e,t)=>({...e,[t]:u.local.get(t)}),{})},[t.THIS_SCRIPT]:{allSourceParams:()=>C((p||(p=S()),p))}};function w(e,t=null){const r=i[e],n=r.nameWords.join(""),o=r.nameWords.join("_").toUpperCase(),a=`inputSourceSelect âž” get value of ${n}.`;L(!0,a),v(`argument param: ${e}, uppercase join of nameWords: ${o}`);v(`${n}'s available sources are: ${P(r.availableSourcesSorted.map(e=>e.toLowerCase().replaceAll(/(?<=_)(.)/gi,(e,t)=>t.toUpperCase())).map(e=>e.charAt(0).toUpperCase()+e.slice(1)))}.`);
// Always search sources first
for(let e of r.availableSourcesSorted){const t=_[e];v(`Looking in ${e}`),Object.entries(t.allSourceParams()).forEach(([e,t])=>{v(`â¤· ${e} = ${t}`)});const n=N(r.nameWords,t.allSourceParams());if(n)return v(`Param:${o} was found âœ… in Source:${e} with value:${n}.`),L(!1,"1 "+a),String(n);v(`Param:${o} isn't in ${e}.`)}
// If not found, use currentValue if provided and valid, else default
if(v(`Param:${o} was not found âŒ in all sources.`),null!=t)try{return d({[e]:t},e),v(`Param:${o} was set to provided currentValue '${t}'.`),L(!1,"3 "+a),t}catch(e){}
// Fall back to default if exists
return"defaultValue"in r?(v(`Param:${o} was set to fallback default value '${r.defaultValue}'.`),L(!1,"4 "+a),r.defaultValue):(v(`Param:${o} has no default value, no current value, and isnt' in any source.`),L(!1,"5 "+a),null)}const E=Object.entries(i).map(([e,t])=>({...t,keyName:e})).filter(e=>e.availableSourcesSorted.includes("THIS_SCRIPT")).map(e=>e.keyName);class A{API_KEY="";CAMPAIGN_ID="";BASE_URL=i.BASE_URL.defaultValue??"";TRACE_ID=i.TRACE_ID.defaultValue??"";TTY_LEVEL=i.TTY_LEVEL.defaultValue??"";CHECKOUT_URL=i.CHECKOUT_URL.defaultValue??"";ttylvl=0;utmSource=null;constructor(){}update(){Object.entries(function(){const e=Object.keys(i),t={};for(const r of e){const e=w(r);t[r]=null==e?null:e}return t}()).forEach(([e,t])=>{this[e]=t}),isNaN(Number(this.TTY_LEVEL))?this.ttylvl=n[this.TTY_LEVEL.toLowerCase()]||0:this.ttylvl=Number(this.TTY_LEVEL),this.updateUtmSource()}updateUtmSource(){L(!0,"inputSourceSelect âž” utm_source"),v("UTM_Src: request to be updated");const e=function(e){T.groupCollapsed("Parse UTM Source");let t=location.search;t||(t=location.href.split("?")[1]),e&&e?.length>2&&(t=e);try{const e=new URLSearchParams(t).get(o);if(!e)return T.debug("No utm_source found in URL",location.href,{UTM_SOURCE_ID_PARAM:o,baseSearch:t}),T.groupEnd(),null;
// Parse format: trace_id::api_key
const r=e.split("::");if(2!==r.length)return T.warn(`Invalid utm_source format: ${e} (expected: trace_id::api_key)`),T.groupEnd(),null;const[n,a]=r;
// Basic validation
if(!n||!a)return T.warn(`Invalid utm_source parts: trace_id="${n}", api_key="${a}"`),T.groupEnd(),null;
// URL decode in case it's encoded
const i=decodeURIComponent(n),c=decodeURIComponent(a);return T.log(`Parsed utm_source: trace_id="${i}", api_key="${c}"`),T.groupEnd(),{traceId:i,apiKey:c}}catch(e){return T.error("Failed to parse utm_source:",e),T.groupEnd(),null}}
/**
 * Sets or updates the utm_source parameter in the current URL
 * without reloading the page
 */();if(e?.traceId&&e.apiKey)this.TRACE_ID=e.traceId,this.API_KEY=e.apiKey,this.utmSource=`${this.TRACE_ID}::${this.API_KEY}`,v("UTM_Src: â¬‡ï¸ Obtained from URL",{trace_id:this.TRACE_ID,api_key:this.API_KEY});else if(v("UTM_Src: Not found in URL"),this.TRACE_ID&&this.API_KEY)this.utmSource=`${this.TRACE_ID}::${this.API_KEY}`,v("UTM_Src: âš™ï¸ Requirements to generate new utm_source are met"),v(`UTM_Src: âœ… New utm_source: ${this.utmSource}`);else{this.utmSource=null;let e=P(["TRACE_ID","API_KEY"].filter(e=>0==Boolean(this[e])));e=e+" "+(1===e.length?"is":"are"),v(`UTM_Src: can't generate new utm_source when ${e} empty.`)}L(!1,"inputSourceSelect âž” utm_source")}updateParamsThatMightNotHaveReadFromScriptElm(){const e=E.filter(e=>void 0===this[e]);e.forEach(e=>this.refresh(e));const t=e.map(e=>[e,this[e]]).filter(e=>null!=e[1]);if(t.length>0){v(`( ! ) updateParamsThatMightNotHaveReadFromScriptElm has found values for ${P(t.map(e=>String(e[1])))}`)}}updateScriptTiedParamIfNeeded(e){if(i[e].availableSourcesSorted.includes("THIS_SCRIPT")){let t=this[e];this.refresh(e),t!==this[e]&&v("( ! ) Update Script Tied Param If Needed - this was useful!")}}refresh(e,t=!1){let r=w(e,t?void 0:this[e]);
//@ts-ignore
r||(r=i[e].defaultValue),r||(r=""),this[e]=r}asObject(){
// this.updateParamsThatMightNotHaveReadFromScriptElm()
this.update();const e=this;return new Proxy({},{get(t,r){switch(r){case"apiKey":return e.getApiKey();case"campaignId":return e.getCampaignId();case"baseUrl":return e.getBaseUrl();case"traceId":return e.getTraceId();case"ttyLevel":return e.getTtyLevel();case"checkoutUrl":return e.getCheckoutUrl();case"utmSource":return e.getUtmSource();default:return}},set(t,r,n){switch(r){case"apiKey":return e.API_KEY=n,!0;case"campaignId":return e.CAMPAIGN_ID=n,!0;case"baseUrl":return e.BASE_URL=n,!0;case"traceId":return e.TRACE_ID=n,!0;case"ttyLevel":return e.TTY_LEVEL=n,!0;case"checkoutUrl":return e.CHECKOUT_URL=n,!0;case"utmSource":return e.utmSource=n,!0;default:return!1}}})}getApiKey(){
// console.trace(`Asked for API_KEY "${this.API_KEY}`)
// this.updateScriptTiedParamIfNeeded("API_KEY");
return this.API_KEY}setApiKey(e){e&&(this.API_KEY=e)}getCampaignId(){
// console.trace(`Asked for CAMPAIGN_ID "${this.CAMPAIGN_ID}`)
// this.updateScriptTiedParamIfNeeded("CAMPAIGN_ID");
return this.CAMPAIGN_ID}setCampaignId(e){e&&(this.CAMPAIGN_ID=e)}getBaseUrl(){
// this.updateScriptTiedParamIfNeeded("BASE_URL");
return this.BASE_URL}setBaseUrl(e){e&&(this.BASE_URL=e)}getTraceId(){
// console.trace(`Asked for TRACE_ID "${this.TRACE_ID}`)
// this.updateScriptTiedParamIfNeeded("TRACE_ID");
return this.TRACE_ID}setTraceId(e){e&&(this.TRACE_ID=e)}getTtyLevel(){
// this.updateScriptTiedParamIfNeeded("TTY_LEVEL");
return this.TTY_LEVEL}setTtyLevel(e){e&&(this.TTY_LEVEL=e)}getCheckoutUrl(){
// this.updateScriptTiedParamIfNeeded("CHECKOUT_URL");
return this.CHECKOUT_URL}setCheckoutUrl(e){e&&(this.CHECKOUT_URL=e)}
// console levels
getCanTTY(e){let t=e;if("string"==typeof t&&(t=n[t]),isNaN(+t)||null==t)return v(`Attemp to check if can log invalid log level '${t}'`),!1;return!!(this.ttylvl>=t)||(v(`Attempt to log '${t}' denied, current ttyLvl: '${this.ttylvl}'.`),!1)}static _instance;static get instance(){return this._instance??=new A}getSelf(){return this}getUtmSource(){return this.utmSource||(this.refresh("API_KEY"),this.refresh("TRACE_ID"),this.updateUtmSource()),this.utmSource}}const R=A.instance;
/* harmony default export */var b;!function(e){e.before=function(e,t){return(...r)=>e(...t(...r))},e.after=function(e,t){return(...r)=>t(e(...r))}}(b||(b={}));const I={error:["#ff4d4f","#2a0000"],warn:["#ffcc00","#2a2300"],info:["#29e3c0","#0f2220"],group:["inherit","inherit"],groupCollapsed:["inherit","inherit"],groupEnd:["inherit","inherit"],log:["#cccccc","#1e1e1e"],debug:["#7cf17c","#0f210f"],trace:["#9ba3ae","transparent"]},T=(()=>{const e=Object.keys(n),t=(...e)=>{},r=new Proxy({},{get:()=>t});
// is [console] object available?
try{if(!console)return r;for(let t of e)if("function"!=typeof console[t])return v(`trkiout â†’ ${console[t]} is not a function`),r}catch(e){v("trkiout â†’ failed E1:",e);try{R.getCanTTY("error")}catch(e){v("trkiout â†’ can not console error at all",e);
// can't console.error at all
}return r}
// internalDebug(`trkiout â†’ Passed Safeguard 1`);
// console wrapper
return new Proxy({},{get(r,n){
// internalDebug(`trkiout.${prop} â†’ ${typeof prop === "string"}, ${methods.includes(prop)}, ${!!console[prop]}, ${ParamSource.getCanTTY(prop)}`)
if("string"!=typeof n)return t;
// trkiout.[error|warn|log|info|debug|trace] only
if(!e.includes(n))return t;
// double check
const o=console[n];if(!o)return t;
// does it have permission to log?
if(!R.getCanTTY(n))return t;const[a,i]=I[n],c=`color:${a}; background:${i}; padding:1px 4px; border-radius:4px; font-weight:600; letter-spacing: 0.5px`;
// yes i can log that.
// internalDebug(`trkiout â†’ Passed Safeguard 2`);
return(...e)=>{
// let me prefix some stuff:
"string"==typeof e[0]?e[0]=`%c[TRAKI]%c ${e[0]}`:e=["%c[TRAKI]%c",...e],e=[e[0],c,"",...e.slice(1)],
//and log it.
o(...e)}}})})();
/**
 * Console[.log][.error][.info][.debug][etc] replacement, controlled by source param flags that enable it.
 */(()=>{const e=["false","close","wrong","dead","absent","positiv"],t=["y","1","sim","one","um"],r=["true","open","right","alive","present","unknown","null","undefined","negativ","nope","zero"],n=["n","0","on","nÃ£o","nao"]})();
/**
 * Sleep utility for retry delays
 */
function U(e){return new Promise(t=>setTimeout(t,e))}
/**
 * Debug function for when trkiout isnt available
 */function L(e,t){0}
/**
 * Debug function for when trkiout isnt available
 */function v(...e){let t="%c[IN-DEBUG]%c",r=e[0],n=e.slice(1),o=[],a=!1;"string"==typeof r?r=`${t} ${r}`:(o=[t,r,n],a=!0);o=[...a?[t]:[],r,"color:#3c3c3c; background:#BCD; padding:1px 4px; border-radius:4px; font-weight:600; letter-spacing:0.5px;","",n]}
/**
 * Gets a debounced version of a function.
 *
 * Debounce be like:
 * const dbncdFunc = getDebouncedFn(func);
 * dbncdFunc();
 * dbncdFunc();
 * dbncdFunc();
 * // 134 ms later:
 * dbncdFunc();
 * // 380 ms later:
 * dbncdFunc();
 * ...
 * // 400ms later:
 * func() is executed
 *
 *
 * // 490 ms later:
 * dbncdFunc()
 *
 * // 890ms later:
 * func() is executed
 */function $(e,t=400){let r;return function(...n){const o=this;return clearTimeout(r),new Promise((a,i)=>{r=setTimeout(()=>{try{a(e.apply(o,n))}catch(e){i(e)}},t)})}}function C(e){let t={};const r=e?.attributes;if(r)try{for(const e of r)t[e.name]=e.value}catch(t){T.error("Failed to iterate all attributes of element",e),T.trace(t)}return t}
/**
 * To Corrdinated Noun Phrase
 * Join a list of terms using seralized commas, but join them with the last
 * by connecting them with a conjunction term, like "or".
 * @param {string[]} list A list of words, like ["oranges", "apples", "bananas"].
 * @param {boolean|string} [isDisjunctive=false]
 *    false ðŸ š "and", true ðŸ š "or".
 *    This argument defines wether the items in the list define a set of different
 *    possibilities, aka an disjunctive list (and it should use the conjunction "or"),
 *    or if the terms are an aggregation, combination or conjuction of items, aka
 *    an conjunctive list (and then it should use the conjunction "and").
 *    Should you desire another kind of conjunction, like "nor", provide a string.
 * @param {boolean} [useOxfordComma=false]
 *    automatically applied when the provided list is exactly three terms.
 *    false: "we invited the doctors, trump  and obama" ðŸ š there are two doctors
 *    true:  "we invited the doctors, trump, and obama" ðŸ š two presidents
 *    Although this solves a specific case of ambiguity, in most of the scenarios
 *    it is not needed.
 * @returns {string} "oranges, apples and bananas"
 */function P(e,t=!1,r=void 0){if(!e)return"";const n=(Array.isArray(e)&&null!==e.length?e:[]).filter(e=>null!=e).map(e=>"function"==typeof e.toString?e.toString():String(e));if(0===n.length)return"";if(1===n.length)return n[0];if(2===n.length)return n[0]+" and "+n[1];(3===n.length&&null===r||void 0===r)&&(r=!0);return[e.slice(0,-1).join(", "),r?", ":" ",("string"==typeof t?t:["and","or"][+!!t])+" ",n[n.length-1]].join("")}function O(e,t){if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(e[r]!==t[r])return!1;return!0}const k=new RegExp("([^a-z0-9A-Z\n]+|(?<=[a-z])(?:\b|B)(?=[A-Z][a-z]+)|(?<=[a-z]{2,})(?:\b|B)(?=[A-Z]{2,})|(?<=[A-Z]{2,})(?:\b|B)(?=[a-z]{2,}))","g"),K="ï½œ";// Fullwidth Vertical Bar
function N(e,t){let r=[];for(const[n,o]of Object.entries(t)){const t=n.replace(/^data./gi,"").replaceAll(k,K),a=t.split(K),i=a.map(e=>e.toLowerCase());if(O(i,e)){v(`Tried all these: ${r.join(", ")} but none match with ${e.join("")}.`);return v("found!",{attrName:n,attrValue:o,attrNameMarked:t,attrWords:a,normalizedKeyWords:i}),o}r.push(n),r.length>10&&(v(`Tried all these: ${r.join(", ")} but none match with ${e.join("")}.`),r=[])}}
/**
 * Turns a glob pattern to an actual regexp of that glob.
 *
 * @param pattern glob string
 * @returns RegExp of the glob
 */
function D(e){let t=e.replace(/([.?+^$[\]\\(){}|\/-])/g,"\\$1").replace(/\*/g,".*");return new RegExp(t)}// ./src/functions/listenOutbound.ts
// =========================
//   MUTATION OBSERVER (links)
//   auto-UTM all anchors, existing + dynamic
// =========================
const M="data-traki-ed",j="data-traki-og";let B=location.href;function F(e){T.groupCollapsed("Listen to outbound events"),
// #region Observer
function({getFinalURL:e,dispatchEvent:t}){if(T.debug("Will listen to DOM changes"),!("MutationObserver"in window))return void T.error("MutationObserver doesnt exist in window");function r(t){if(!t||!t.getAttribute)return;const r=t.getAttribute("href");if(r&&(t.hasAttribute(j)||t.setAttribute(j,r),"trakied"!==t.getAttribute(M)))try{T.debug("Adding UTM to url of new <a href>");const n=new URL(r,location.href).toString(),o=e(n);o!==n&&(t.href=o),t.setAttribute(M,"trakied")}catch{
// ignore invalid URLs
}}
// initial pass
const n=document.querySelectorAll("a[href]");n.forEach(e=>r(e)),T.debug(`Initially found ${n.length} <a href> in this page.`);new MutationObserver(e=>{for(const t of e)"childList"===t.type?t.addedNodes.forEach(e=>{const t=e;1===t.nodeType&&("A"===t.tagName&&t.hasAttribute("href")&&r(t),t.querySelectorAll&&t.querySelectorAll("a[href]").forEach(e=>r(e)))}):"attributes"===t.type&&"href"===t.attributeName&&"A"===t.target.tagName&&r(t.target)}).observe(document.documentElement,{childList:!0,subtree:!0,attributes:!0,attributeFilter:["href"]}),T.debug("Listener for DOM Changes deployed.")}

// #endregion Observer
// =============================================================================
// #region Evt_Click

(e),function({getFinalURL:e,dispatchEvent:t}){T.debug("Will listen to <a href> clicks"),document.addEventListener("click",r=>{const n=r.target&&"function"==typeof r.target.closest&&r.target.closest("a[href]");if(!n)return;const o=n.getAttribute("href");T.debug(`There was a click in one of the observed anchor elements: <a href="${o||"??"}">`);const a=n.getAttribute(j)||o||n.href;let i;try{i=new URL(a,location.href).toString()}catch{i=a}const c=e(i);n.href=c,t("linkclick",i,{href:c,originalHref:a,domHref:o,
// target: a.target || "_self",
// domPath: getDomPath(a),
// text: getTextPreview(a),
// dataset: copyDataset(a),
modifiers:{ctrl:r.ctrlKey,meta:r.metaKey,shift:r.shiftKey,alt:r.altKey,button:r.button}})}),T.debug("Listener for anchor clicks deployed/")}(e),
// #endregion Evt_Click
// =============================================================================
// #region Evt_Form
function({getFinalURL:e,dispatchEvent:t}){T.debug("Will listen to form submission events"),document.addEventListener("submit",r=>{const n=r.target;if(!n||!n.action)return;T.debug(`There was a submission of a form: action="${n.action}"`);const o=n.action,a=e(o);n.action=a,t("FormSubmit",o,{action:a,originalAction:o,method:(n.method||"GET").toUpperCase()})}),T.debug("Listener for Form Submissions deployed")}

// #endregion Evt_Form
// =============================================================================
// #region PopState

(e),function({getFinalURL:e,dispatchEvent:t}){window.addEventListener("popstate",e=>{T.debug("An history state has been popped."),t("PopState",function(){const e=B;return B=location.href,e}(),e.state)}),T.debug("Listener for PopState deployed")}

// #endregion PopState
// =============================================================================
// #region Evt_Unload

(e),function({getFinalURL:e,dispatchEvent:t}){window.addEventListener("beforeunload",()=>{T.debug("Page is about to be unloaded."),t("BeforeUnload",location.href)}),window.addEventListener("unload",()=>{T.debug("Unloading page"),t("OnUnload",location.href)}),T.debug("Listener for [Before]Unload deployed")}

// #endregion PopState
// =============================================================================
// #region Evt_Unload

(e),
// listenToNavigate(urlEventParams);
T.groupEnd()}// ./src/functions/patchToIntercept.ts
// =============================================================================
// #region Helpers
// function getFinalURL(destinyURL?: string | URL): string {
//   return addUTM(destinyURL);
// }
// function dispatchEvent(type: string, destinyURL?: string | URL, args?: unknown[]): void {
//   trkiout.log(`Dispatch Event from intercepted method: ${type}, ${destinyURL}, ${(args||[]).join(", ")}`);
//   return;
// }
// #endregion Helpers
// =============================================================================
// #region Intercept
function V(e){T.groupCollapsed("Patch global methods by Intercept");try{!
// #endregion Intercept
// =============================================================================
// #region WindowOpen
function({getFinalURL:e,dispatchEvent:t}){T.debug("Patching window.open()");const r=window.open;if(!r)return void T.error("Failed to patch window.open because there's no 'open'");window.open=function(n,o,a){return t("WindowOpen",n,{target:o,features:a}),r.call(this,e(n),o,a)},T.debug("Patched window.open.")}

// #endregion WindowOpen
// =============================================================================
// #region Location

// function patchLocation({ getFinalURL, dispatchEvent }: UrlEventParams) {
//   const proto = Object.getPrototypeOf(window.location);
//   const desc = Object.getOwnPropertyDescriptor(proto, "href");
//   if (desc && desc.configurable && desc.set && desc.get) {
//     Object.defineProperty(proto, "href", {
//       set(_url) {
//         dispatchEvent("LocationHrefSet", _url);
//         if (typeof desc.set === "function") {
//           return desc.set.call(this, getFinalURL(_url));
//         }
//       },
//       get() {
//         return desc.get!.call(this);
//       }
//     });
//   }
//   function wrap(name: "assign" | "replace") {
//     const orig = location[name];
//     if (typeof orig !== "function") return;
//     location[name] = function (_url: string) {
//       dispatchEvent(`Location${name.charAt(0)+name.slice(1)}`, _url);
//       return orig.call(this, getFinalURL(_url))
//     }
//   }
//   wrap("assign");
//   wrap("replace");
// };
/**
 * Intercepts window.location.href and related methods to add utm_source
 * Uses multiple strategies to ensure coverage across different browsers and scenarios
 */(e)}catch(e){return T.trace("Failed to patch WindowOpen",e),e}try{!function({getFinalURL:e,dispatchEvent:t}){T.debug("Patching location.href, location.assign, location.replace");let r=!1;
// Strategy 1: Try to intercept Location.prototype.href setter (most comprehensive)
try{const n=Object.getOwnPropertyDescriptor(Location.prototype,"href");if(n&&n.set&&n.configurable){const o=n.set;Object.defineProperty(Location.prototype,"href",{set:function(r){try{const n=e(r);T.debug(`[window.location.href] Intercepted: ${r} â†’ ${n}`),t("LocationSet",r),o.call(this,n)}catch(e){T.debug("[window.location.href] Interception failed:",e),o.call(this,r)}},get:n.get,enumerable:!0,configurable:!0}),r=!0,T.log("âœ… window.location.href setter intercepted (Location.prototype)")}}catch(e){T.debug("Failed to intercept Location.prototype.href:",e)}
// Strategy 2: Intercept window.location.assign (fallback/additional)
try{const r=window.location.assign;window.location.assign=function(n){try{const o=e(n);T.debug(`[window.location.assign] Intercepted: ${n} â†’ ${o}`),t("LocationAssign",n),r.call(this,o)}catch(e){return T.debug("[window.location.assign] Interception failed:",e),r.call(this,n)}},T.log("âœ… window.location.assign intercepted")}catch(e){T.debug("Failed to intercept window.location.assign:",e)}
// Strategy 3: Intercept window.location.replace (fallback/additional)
try{const r=window.location.replace;window.location.replace=function(n){try{const o=e(n);T.debug(`[window.location.assign] Intercepted: ${n} â†’ ${o}`),t("LocationReplace",n),r.call(this,o)}catch(e){return T.debug("[window.location.replace] Interception failed:",e),r.call(this,n)}},T.log("âœ… window.location.replace intercepted")}catch(e){T.debug("Failed to intercept window.location.replace:",e)}r||T.warn("âš ï¸ window.location.href not directly intercepted. Using fallback methods (assign/replace).")}

// #endregion Location
// =============================================================================
// #region History

(e)}catch(e){return T.trace("Failed to patch Location",e),e}try{!function({getFinalURL:e,dispatchEvent:t}){function r(r){T.debug(`Patching history.${r}()`);const n=history[r];"function"==typeof n?(history[r]=function(o,a,i){
// trkiout.log(`History.${name}(state, ${title}, ${_url} â‡¾ ${getFinalURL(_url as any)})`, state);
// @ts-ignore
return t(`History${r.charAt(0)+r.slice(1)}`,i,{state:o,title:a}),n.apply(this,[o,a,e(i)])},T.debug(`Patched history.${r} successfully.`)):T.error(`Failed to patch history.${r} - not a function`)}T.debug("Patching History"),r("pushState"),r("replaceState")}

// #endregion History
// =============================================================================
(e)}catch(e){return T.trace("Failed to patch History",e),e}T.groupEnd()}function H(e,t,r={}){const n={maxRetries:3,retryDelay:1e3,requestTimeout:5e3,method:"POST",apiKey:R.getApiKey(),baseUrl:R.getBaseUrl(),omitParams:[],...r||{}};n.headers={accept:"application/json","Content-Type":"application/json",Authorization:`Bearer ${n.apiKey}`,...r?.headers||{}};
// Separate 'name' from the rest of the data to construct proper payload
const{name:o,...a}=t;let i={...o?{name:o}:{},...a};Array.isArray(n.omitParams)&&(T.info("requestBody before omitParams: ",i),i=Object.entries(i).reduce((e,[t,r])=>n.omitParams?.includes(t)?e:{...e,[t]:r},{}),T.info("New requestBody after omitParams: ",i));const c=g(n,[["apiKey",d]]);if(!c.valid)return c.fields.forEach(({field:e,value:t,msg:r})=>T.error(r,t,e)),{abort:()=>{},response:new Promise(e=>e({success:!1,data:null,error:{msg:"Validation failed"}}))};const s=new AbortController,u=// ./src/types/api.ts
/**
 * Constructs a normalized URL by concatenating a base URL, version, and path segments.
 * It trims redundant slashes and ignores null/undefined/empty parts.
 *
 * @param {string | (string | number | null | undefined)[]} path
 *   The path string or array of path segments.
 *   When an array is provided, falsy items (`null`, `undefined`, `""`, `false`) are skipped.
 * @param {string | null | undefined} [baseURL=""]
 *   Optional base URL. Falls back to `ParamSource.getBaseUrl()` if falsy.
 * @param {TVersionParam} [version="v1"]
 *   API version prefix (e.g. `"v1"`, `"v2"`). Included in the URL after the base.
 * @returns {string}
 *   A fully composed, slash-normalized URL string.
 *
 * @example
 * getURL("/events")
 * // â†’ "https://example.com/v1/events"
 *
 * @example
 * getURL(["user", userId, "orders", orderId, "products"], API_URLS.orders, "v2")
 * // â†’ "https://orders.api/v2/user/123/orders/456/products"
 *
 * @example
 * getURL("user/123/orders/456/products")
 * // â†’ "https://example.com/v1/user/123/orders/456/products"
 *
 * @example
 * getURL(["products", productId, "images", hasImage && imageId]) âž” given hasImage is true
 * // â†’ "https://example.com/v1/products/42/images/7"
 *
 * @example
 * getURL(["products", productId, "images", hasImage && imageId]) âž” when there's no image
 * // â†’ "https://example.com/v1/products/42/images
 */
function(e,t="",r="v1"){return[t||R.getBaseUrl(),r].concat(Array.isArray(e)?e:[e]).filter(e=>null!=e&&""!==e).map(e=>String(e).replace(/^\/+|\/+$/g,"")).join("/")}(e,n.baseUrl);let l=null;const f=null==n.maxRetries?3:n.maxRetries,h=null==n.retryDelay?1e3:n.retryDelay;return{abort:()=>s.abort(),response:async function(){let e={success:!1,data:null,error:{msg:"unknown error"}};for(let t=0;t<=f;t++)try{const r=AbortSignal.timeout(n.requestTimeout||5e3),o=await fetch(u,{method:n.method,headers:n.headers,body:JSON.stringify(i),signal:AbortSignal.any([s.signal,r])});let a;try{a=await o.json()}catch(e){try{a=await o.text()}catch(e){a=e}}if(o.ok)return e={success:!0,error:null,data:a},a.data&&(e.data=a.data),a.data?.data&&(e.data=a.data.data),e;if(a.status>=400&&a.status<500&&(e={success:!1,error:{msg:`API request failed with status ${a.status}`,details:a,response:o},data:null}),
// Retry on server errors (5xx)
l=new Error(`Server error: ${a.status}`),t<f){await U(h*(t+1));// Exponential backoff
continue}}catch(r){
// Don't retry on abort/timeout for the last attempt
if(l=r instanceof Error?r:new Error("Unknown error"),t<f&&!l.message.includes("aborted")){e={success:!1,data:null,error:{msg:"DoRequest Failed all retries",details:{lastError:l,error:r}}},await U(h*(t+1));continue}}return e}()}}
/**
 * Record any Event from user interaction.
 *
 * This is the generic event seneder function and should be used as the only way to make requests that are about "create a record" and under the topic "event".
 * @param {string} eventName one of the accepted event names
 * @param {object} eventData object with the data that the event expects to receive.
 * @param {object} options{} Request behavior settings, only necessary in very specific scenarios.
 * @returns The data responded by the server if the request succeeds, or null if it fails.
 */async function Y(e,t,r={}){const n=g({eventName:e,traceId:R.getTraceId()},[["eventName",d],["traceId",d]]);if(!n.valid)return n.fields.forEach(({field:e,value:t,msg:r})=>T.error(r,t,e)),new Promise(e=>e(null));const o=window.location.href,a={
// @ts-ignore
from:x||document.referrer||void 0,
// @ts-ignore
to:o,
// @ts-ignore
title:document.title,viewport:{width:window.innerWidth,height:window.innerHeight},screen:{width:window.screen?.availWidth,height:window.screen?.availHeight,pxDepth:window.screen?.pixelDepth,colDepth:window.screen?.colorDepth,orientation:window.screen?.orientation?.type||"unknown",
// @ts-ignore
angle:window.screen?.angle||0,
// @ts-ignore
extended:window.screen?.isExtended},...t?.payload||{}};
// Payload (dynamic - can have any fields)
// Update last URL for next navigation
x=o;
// Metadata (strict schema - only allowed fields)
const i={action_source:"WEBSITE",user_agent:navigator.userAgent,screen_height:window.screen?.availHeight,screen_width:window.screen?.availWidth,locale:navigator.language,page_url:o,page_referrer:document.referrer||void 0,...t?.metadata||{}},c={trace_id:R.getTraceId(),campaign_id:R.getCampaignId(),created_at:(new Date).toISOString(),name:e,payload:a,metadata:i};r.apiKey=R.getApiKey(),r.baseUrl=R.getBaseUrl();const s=H("/events",c,r),u=await s.response;return u.success?u.data:(T.error(`Failed to sendEvent ${e}: ${u.error.msg}`,{details:u.error.details}),null)}
// Store last URL to track navigation
let x="";
/**
 * Track page view event
 */const G=$(async function(e,t){const r=window.location.href,n=x||document.referrer||void 0,o={to:r,from:n,title:document.title,navigationMethod:e,...t||{}},a=await Y("PageView",{payload:o,metadata:{}}),i=Boolean(a);return T.log(i?`Sent PageView: ${n} -> ${r}`:"Failed to send PageView event"),i},600);const W=$(async function(e,t){const r=window.location.href,n=x||document.referrer||void 0,o={to:r,from:n,navigationMethod:e,...t||{}},a=await Y("InitCheckout",{payload:o,metadata:{}}),i=Boolean(a);return T.log(i?`Sent InitCheckout: ${n} -> ${r}`:"Failed to send InitCheckout event"),i},600);
/**
 * Track before redirect event
 */ // ./src/export/traki.ts
try{Error.stackTraceLimit=100}catch(e){}
// TODO: intercept and add utm_source to
// - a[href]
// - window.open
// - form submit
// - redirect
function q(e,t){const r=u.session.get(e);r!=t?(u.session.set(e,t),T.log(`Updated ${e} in session storage, stored value "${r}" is outdated since new value "${t}" is found.`)):T.debug(`Did not update ${e} in session storage because the stored value "${r}" is the same as the new value "${t}"`)}
// /**
//  * Main Traki tracking initialization
//  */
// export async function traki() {
//   await sleep(400);
//   let config: ParamSourceObject = ParamSource.asObject();
//   let utmSrc = parseUtmSource();
//   for (let retry = 0; retry < 3; retry ++) {
//     if (config.apiKey && config.campaignId && utmSrc) {
//       break;
//     }
//     await sleep(300);
//     ParamSource.update();
//     config = ParamSource.asObject();
//     if (!utmSrc) {
//       utmSrc = parseUtmSource();
//     }
//   }
//   let missingParams = [];
//   if (utmSrc) {
//     trkiout.log([
//       `Found UTM_SOURCE in URL and it matches TRAKI's hashed data. Will override:`,
//       `- API_KEY was "${config.apiKey}" now is "${utmSrc.apiKey}"`,
//       `- TRACE_ID was "${config.traceId}" now is "${utmSrc.traceId}"`
//     ].join("\n"))
//     stores.session.set(STORAGE_KEYS.API_KEY, utmSrc.apiKey);
//     config.apiKey = utmSrc.apiKey;
//     stores.session.set(STORAGE_KEYS.TRACE_ID, utmSrc.traceId);
//     config.traceId = utmSrc.traceId;
//   } else {
//     trkiout.log("Did not found a valid UTM_SOURCE in url.");
//   }
//   if (!config.campaignId) { missingParams.push("campaign_id"); }
//   if (!config.apiKey) { missingParams.push("api_key"); }
//   if (!config.baseUrl) { missingParams.push("base_url"); }
//   if (!config.checkoutUrl) { missingParams.push("checkoutUrl"); }
//   if (missingParams.length > 0) {
//     trkiout.error(`Missing Params: ${missingParams.join(",")}. Cannot start event tracking`);
//     return;
//   } else {
//     trkiout.log("Required params ok");
//   }
//   const storedApiKey = stores.session.get(STORAGE_KEYS.API_KEY);
//   if (storedApiKey != config.apiKey) {
//     stores.session.set(STORAGE_KEYS.API_KEY, config.apiKey);
//     trkiout.log(`Updated ${STORAGE_KEYS.API_KEY} in session storage from "${storedApiKey}" to "${config.apiKey}"`);
//   }
//   const hasExistingTraceId = Boolean(config.traceId);
//   if (!hasExistingTraceId) {
//     trkiout.log('TraceID not found, generating one');
//     const isTraceCreated = await createTrace();
//     if (!isTraceCreated) {
//       trkiout.error('Failed to create traceId, cannot start event tracking');
//       return;
//     }
//   } else {
//     trkiout.log("TraceID: reused existing traceid '"+config.traceId+"'.")
//   }
//   // Initialize utm_source after trace_id is available
//   initUtmSource();
//   trkiout.log("Initialized successfully - PageView tracking enabled");
//   // Track initial page view
//   trackPageView();
//   // Track page view on every load/navigation
//   onLoad(() => {
//     trackPageView();
//   });
//   // Track page view on SPA navigation (React Router, etc)
//   onRedirect((state) => {
//     trkiout.log(`Navigation detected: ${state.from} -> ${state.to}`);
//     trackPageView();
//   });
//   // TODO: onFormSubmit
// }
// // -------------------------------------
/******/!async function(){
// get params from first source where they're available
const t=R.asObject();T.debug([" says:","â”Œâ”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”","â”œâ”¼â”¼â”´â”´â”´â”´â”´â”´â”´â”¼â”¼â”¼â”´â”´â”´â”´â”´â”´â”´â”¼â”¼â”¼â”´â”´â”´â”´â”´â”´â”´â”¼â”¼â”¼â”´â”¼â”¼â”¼â”¼â”´â”´â”¼â”¼â”¼â”´â”´â”´â”´â”´â”´â”´â”¼â”¼â”¤","â”œâ”¼â”¼â”¬â”¬â” â”Œâ”¬â”¬â”¼â”¼â”¤ â”Œâ”¬â”¬â”¬â” â”œâ”¼â”¤ â”Œâ”¬â”¬â”¬â” â”œâ”¼â”¤ â”œâ”¼â”¼â”˜ â”¬â”¼â”¼â”¼â”¬â”¬â” â”Œâ”¬â”¬â”¼â”¼â”¤","â”œâ”¼â”¼â”¼â”¼â”¤ â”œâ”¼â”¼â”¼â”¼â”¤ â””â”´â”´â”´â”˜ â”œâ”¼â”¤ â””â”´â”´â”´â”˜ â”œâ”¼â”¤ â”œâ”˜ â”Œâ”¼â”¼â”¼â”¼â”¼â”¼â”¼â”¤ â”œâ”¼â”¼â”¼â”¼â”¤","â”œâ”¼â”¼â”¼â”¼â”¤ â”œâ”¼â”¼â”¼â”¼â”¤ â”Œâ”¬â” â”€â”¬â”¼â”¼â”¤ â”Œâ”¬â”¬â”¬â” â”œâ”¼â”¤   â”€â”´â”¼â”¼â”¼â”¼â”¼â”¼â”¼â”¤ â”œâ”¼â”¼â”¼â”¼â”¤","â”œâ”¼â”¼â”¼â”¼â”¤ â”œâ”¼â”¼â”¼â”¼â”¤ â”œâ”¼â”¼â” â””â”¼â”¼â”¤ â”œâ”¼â”¼â”¼â”¤ â”œâ”¼â”¤ â”œâ”¼â”¬  â””â”¼â”¼â”¼â”´â”´â”˜ â””â”´â”´â”¼â”¼â”¤","â”œâ”¼â”¼â”¼â”¼â”¼â”¬â”¼â”¼â”¼â”¼â”¼â”¼â”¬â”¼â”¼â”¼â”¼â”¬â”¬â”¼â”¼â”¼â”¬â”¼â”¼â”¼â”¼â”¼â”¬â”¼â”¼â”¼â”¬â”¼â”¼â”¼â”¼â”¼â”¬â”¼â”¼â”¼â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¼â”¼â”¤","â””â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”˜"].join("\n "));
// log params at first bootstrap
T.groupCollapsed("Param Source Values"),T.log(`*apiKey:      "${t.apiKey}"`),T.log(`*campaignId:  "${t.campaignId}"`),T.log(`*baseUrl:     "${t.baseUrl}"`),T.log(`checkoutUrl:  "${t.checkoutUrl}"`),T.log(`ttyLevel:     "${t.ttyLevel}"`),T.log(`utmSource:    "${t.utmSource}"`),T.log(`traceId:      "${t.traceId}"`),T.groupEnd();
// verify obligatory initial params
let r=[];t.apiKey||r.push("api_key");t.campaignId||r.push("campaign_id");t.baseUrl||r.push("base_url");if(r.length>0)return void T.error(`Missing Params: ${r.join(",")}. Cannot start event tracking`);
// create trace_id if none yet
if(!t.traceId){T.log("TraceID not found, generating one");const t=
// #endregion SelChange
// =============================================================================
// #region New_Trace
/**
 * Create a new trace via API
 */await async function(){const t=R.asObject();if(T.groupCollapsed("Will createTrace"),!t.campaignId||!t.apiKey)return T.error("Cannot create trace: missing campaign_id or api_key"),!1;const r=f(),n={campaign_id:t.campaignId,final_url:window.location.href,utm_source:r.utm_source,utm_medium:r.utm_medium,utm_campaign:r.utm_campaign,utm_term:r.utm_term,utm_content:r.utm_content,user_agent:navigator.userAgent,accept_language:navigator.language};T.log("tracePayload:",n);const o=H("traces",n,{...t||{},omitParams:["traceId","trace_id"]}),a=await o.response;if(!a.success)return T.error(`Failed to create trace: ${a?.error?.msg}`,{details:a?.error?.details}),T.groupEnd(),!1;T.log("doRequest('traces') response: ",a.data);let i=a.data?.trace?.id;i||(i=a.data?.id);
// @ts-ignore
// if (!createdTraceId) { createdTraceId = res.data?.data?.trace?.id; }
try{d({trace_id:i},"trace_id");
// validateUUID({ trace_id: createdTraceId}, "trace_id");
}catch(e){return e instanceof l?T.error(`Validation failed: ${e.message}`,{field:e.field,value:e.value}):T.error("Unknown error when validating",e),T.groupEnd(),!1}try{u.session.set(e.TRACE_ID,i)}catch(e){return T.error("Failed to store trace_id in SESSION_STORAGE",e),T.groupEnd(),!1}return R.setTraceId(i),R.getTraceId()===i?(T.debug("ParamSource successfully updated with new trace_id"),T.groupEnd(),!0):(T.error(`Trace ID mismatch after creation ParamSource:"${R.getTraceId()}", Provided by API: "${i}"`),T.groupEnd(),!1)}
// #endregion New_Trace
// =============================================================================
// #region End
// #endregion End
();if(!t)return void T.error("Failed to create traceId, cannot start event tracking");T.log("TraceID created successfully")}R.updateUtmSource(),T.groupCollapsed("Update storage if any value is new"),T.log(`[2] traceId:      "${t.traceId}"`),T.log(`[2] utmSource:    "${t.utmSource}"`),q(e.API_KEY,t.apiKey),q(e.CAMPAIGN_ID,t.campaignId),q(e.BASE_URL,t.baseUrl),q(e.TRACE_ID,t.traceId),q(e.CHECKOUT_URL,t.checkoutUrl),q(e.TTY_LVL,t.ttyLevel),T.groupEnd();let n=[],o=[];t.checkoutUrl&&(n=function(e){try{return e.split(",").map(e=>e.trim()).filter(Boolean).map(D)}catch(e){return T.error(e),[]}}(t.checkoutUrl),a=t.checkoutUrl,o=a.split(",").map(e=>e.trim()).filter(Boolean),T.debug("Configured matcher for checkout URL"));var a;function i(e){let t=!1;if(e&&(
// regex
t=function(e,t){for(let r=0;r<e.length;r++){const n=e[r];if(T.debug(`Testing "${t}" with RegExp Pattern ${r} of ${e.length}: "${n.source}", flags ${n.flags}`),n.test(t))return T.debug(`RegExp Pattern ${r} "${n.source}" matched URL, URL is checkout URL.`),!0}return T.debug(`no RegExp Pattern matched URL "${t}", URL is NOT checkout URL.`),!1}(n,e),!t)){T.debug(`Patterns did not recognize ${e} as CHECKOUT url`);o.some((t,r)=>(T.debug(`Checking if URL "${e}" includes string pattern ${r} of ${o.length} "${t}".`),e.includes(t)?(T.debug(`URL does include the string pattern "${t}", URL is checkout URL`),!0):(T.debug(`URL does not contain string pattern. Checking if URL matches full string "${t}"`),e===t?(T.debug(`URL matches "${t}" exactly, URL is checkout URL`),!0):void T.debug(`URL does not match "${t}" nor contains it, not a checkout URL.`))))&&(t=!0)}return t||T.debug(`URL "${e}" isn't for checkout`),t}const c={getFinalURL:y,dispatchEvent:async function(e,t,r){if(T.debug(`Dispatch Event '${e}'`),"BeforeUnload"===e||"OnUnload"===e)return void T.log("Unload Events not supported yet, skipping event dispatch");let n=t?t instanceof URL?t.toString():String(t):"";n||T.trace("Dispatch Event invoked with empty URL");const o=i(n),a=o?"InitiateCheckout":"PageView";T.log(`Dispatching Event "${a}" from subroutine "${e}"`,r);try{o?await W(e,r):(T.log(`Event of "${a}" sent successfully`),await G(e,r))}catch(e){T.error(`Failed to send ${a} event:`,e)}
// trkiout.groupEnd();
}};T.groupCollapsed("Patch, Listen and Set own UTM source"),V(c),F(c),function(e){T.debug("Will add utm_source to this page's own URL.");try{const t=y(new URL(window.location.href));window.history.replaceState(window.history.state,"",t.toString()),T.log(`utm_source set in this page's URL: "${e}"`)}catch(e){T.error("Failed to set utm_source in URL:",e)}}(t.utmSource),T.groupEnd()}()})();