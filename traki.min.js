/******/(()=>{// webpackBootstrap
/******/"use strict";
// UNUSED EXPORTS: traki
// ./src/constants/constants.ts
// Storage keys
const e=Object.freeze({API_KEY:"TRAKI_API_KEY",TRACE_ID:"TRAKI_TRACE_ID",CAMPAIGN_ID:"TRAKI_CAMPAIGN_ID",BASE_URL:"TRAKI_BASE_URL",SESSION_START:"TRAKI_SESSION_START",CHECKOUT_URL:"TRAKI_CHECKOUT_URL",UTM_SOURCE:"TRAKI_UTM_SOURCE"}),t=Object.freeze({URL_PARAMS:"URL_PARAMS",SESSION_STORAGE:"SESSION_STORAGE",LOCAL_STORAGE:"LOCAL_STORAGE",THIS_SCRIPT:"THIS_SCRIPT"}),r="https://api.traki.io/",n={error:1,warn:2,log:3,info:4,debug:5,group:6,groupCollapsed:6,groupEnd:6,trace:7},a="utm_source",o=t,i={API_KEY:{storageKey:e.API_KEY,required:!0,availableSourcesSorted:[o.THIS_SCRIPT,o.SESSION_STORAGE,o.LOCAL_STORAGE],nameWords:["api","key"]},CAMPAIGN_ID:{storageKey:e.CAMPAIGN_ID,required:!0,availableSourcesSorted:[o.URL_PARAMS,o.SESSION_STORAGE,o.LOCAL_STORAGE,o.THIS_SCRIPT],nameWords:["campaign","id"]},BASE_URL:{storageKey:e.BASE_URL,defaultValue:r,availableSourcesSorted:[o.URL_PARAMS,o.SESSION_STORAGE,o.LOCAL_STORAGE,o.THIS_SCRIPT],nameWords:["base","url"]},TRACE_ID:{storageKey:e.TRACE_ID,defaultValue:"",availableSourcesSorted:[o.URL_PARAMS,o.SESSION_STORAGE,o.LOCAL_STORAGE],nameWords:["trace","id"]},TTY_LEVEL:{storageKey:"",defaultValue:"none",availableSourcesSorted:[o.URL_PARAMS,o.THIS_SCRIPT],nameWords:["tty","lvl"]},CHECKOUT_URL:{storageKey:e.CHECKOUT_URL,defaultValue:"https://pay.gamestickkwai.shop/n1NLgwJDyYVGMxE",availableSourcesSorted:[o.THIS_SCRIPT,o.SESSION_STORAGE,o.LOCAL_STORAGE],nameWords:["checkout","url"]}};
/**
 * External Input Params Sources
 * Define the name of the possible sources to look for the EIPs (External Input Sources).
 *
 * Ex.:
 * The CAMPAIGN_ID might be stored in the SESSION_STORAGE.
 * The TRACE_ID might be provided via URL_PARAMS.
 * The BASE_URL could be set as an attribute of THIS_SCRIPT.
 *
 * The {EIP}'s value is probably defined in an {EIP Source}.
 * The {EIP} must be defined in at least one of the {EIP Sources}.
 *
 * This just names the External Input Param Sources.
 * They are used elsewhere as the keys of an object who assigns functions to them, defining then how exacly these Sources are queried for the EIP values.
 */ // ./src/functions/storage.ts
function s(e){const t=this;return{get:()=>t.get(e),set:r=>t.set(e,r),keys:()=>Object.keys(t)}}function c(e){return{context:s,get:t=>e.getItem(t)??void 0,set(t,r){e.setItem(t,r)},keys:()=>Object.keys(e)}}const u={local:c(localStorage),session:c(sessionStorage)};
/**
 * Validation error class
 */
class l extends Error{field;value;constructor(e,t,r){super(e),this.field=t,this.value=r,this.name="ValidationError"}}
/**
 * Validates required fields are present and non-empty
 */const d=(e,t)=>{if(!e||"string"==typeof e&&""===e.trim())throw new l(`${t} is required`,t,e)};
/**
 * Validates UUID fields
 */
/**
 * Simpler way to validate several properties of an object
 * @param subject Object to validate the properties from
 * @param spec Tuple of propertyName and validator function
 * @returns true for all valid, false if any prop fails validation
 */
function g(e,t){let r={valid:!0,fields:[]};return t.forEach(([t,n])=>{try{n(e[t],String(t))}catch(n){r.valid=!1,n instanceof l?r.fields.push({field:n.field,value:n.value,msg:n.message}):r.fields.push({field:String(t),value:e[t],msg:`Unknown error when validating ${String(t)}`})}}),r}// ./src/functions/URLSearchParamsWrapped.ts
function f(e=""){let t={},r=e;if(!r)try{r=location.search}catch(e){r=""}function n(e){t=function(e){const t={},r=e.startsWith("?")?e.slice(1):e;if(!r)return t;for(let e of r.split("&"))if(e.includes("=")){const[r,o]=e.split("=").map(e=>{try{return decodeURIComponent(e)}catch(e){return""}}),i=r.endsWith("[]"),s=o.includes(",")&&!i;n(t,i?r.slice(0,-2):r,s?o.split(",").map(a):a(o))}else{n(t,decodeURIComponent(e),!0)}return t;function n(e,t,r){if(void 0!==r){if(null!==r)return Array.isArray(r)?(e[t]||(e[t]=[]),void e[t].push(...r)):void(void 0===e[t]?e[t]=r:Array.isArray(e[t])?e[t].push(r):e[t]=[e[t],r]);e[t]=null}}function a(e){const t=e.toLowerCase();return""===t||"null"===t?null:"undefined"!==t?"true"===t||"false"!==t&&(!isNaN(Number(t))&&Number.isFinite(+t)&&""!==t.trim()?Number(t):t):void 0}}(e)}function a(){return Object.entries(t).map(([e,t])=>{const r=encodeURIComponent(e);return Array.isArray(t)&&t?.length>0?t.map(e=>`${r}=${encodeURIComponent(String(e))}`).join("&"):!!t&&`${r}=${encodeURIComponent(String(t))}`}).filter(Boolean).join("&")}return n(r),new Proxy({},{get:(e,r)=>"load"===r?n:r===Symbol.toPrimitive?()=>a():"toString"===r?a:r in t?t[r]:void 0,set:(e,r,n)=>(t[r]=n,!0)})}// ./src/functions/currentScript.ts
const h=Object.values(i).map(e=>e.nameWords);let p=null;function m(e){if(!e)return!1;const t=$(e);if(Object.keys(t).length<1)return!1;return h.map(e=>N(e,t)).filter(Boolean).length>=2}function S(){const e=function(){const e=[document.currentScript,...document.querySelectorAll(`script[src*="${r}"]`),...Array.from(document.scripts).filter(e=>e.src.includes("traki"))],t=new Set,n=[];return e.forEach(e=>{e instanceof HTMLScriptElement&&(t.has(e)||(t.add(e),n.push(e)))}),n}();for(const t of e)if(m(t))return t;return e[0]??null}// ./src/functions/utmSourceManager.ts
function y(e){if(!e)throw new Error(`getFinalURL: invalid argument inputURL with value "${e}"`);let t=Boolean(e)?e instanceof URL?e.toString():String(e):"";const r=v.getUtmSource();
// trkiout.trace(`getFinalURL: will append in "${inputURL}" the utm "${utmSourceVal}"`)
if(!function(e){try{if(!e)return!1;if("#"===e.charAt(0))return!1;if(/^\s*javascript:/i.test(e))return!1;const t=new URL(e,location.href);return!!/^https?:$/i.test(t.protocol)}catch(e){return!1}}(t))
// trkiout.trace(`Trying to add UTM source to invalid URL '${strURL}'`);
return"";const n=new URL(t,location.href);return r?(n.searchParams.set(a,r),n.toString()):(T.error("Failed to append UTM Source to URL"),T.log(`Original URL was '${e}'`),n.toString())}
/**
 * Parses utm_source from URL and extracts trace_id and api_key
 * Expected format: {trace_id}::{api_key}
 * Example: 1953adf5-9f26-4740-ae7f-1d883e0fb674::tk_MhPRG01K_01K9gT5WSR0dJZhyNQJZ0BRCmw
 */ // ./src/functions/inputSourceSelect.ts
const w={[t.URL_PARAMS]:{
// getParamValue: (() => {
//   // TODO: deduplicate "getUrlParameters" function and use siungle utility source
//   const urlParams = Object.fromEntries(new URLSearchParams(window.location.search));
//   return function getParamValue(paramName: string) {
//     let r = urlParams[paramName];
//     if (!r) return null;
//     if (r) r = decodeURIComponent(r);
//     return r;
//   }
// })(),
allSourceParams:()=>f()},[t.SESSION_STORAGE]:{
// getParamValue: (() => {
//   return function getParamValue(paramName: string) {
//     const r = stores.session.get(paramName);
//     return r ? String(r) : null;
//   }
// })(),
allSourceParams:()=>u.session.keys().reduce((e,t)=>({...e,[t]:u.session.get(t)}),{})},[t.LOCAL_STORAGE]:{
// getParamValue: (() => {
//   return function getParamValue(paramName: string) {
//     const r = stores.local.get(paramName);
//     return r ? String(r) : null;
//   }
// })(),
allSourceParams:()=>u.local.keys().reduce((e,t)=>({...e,[t]:u.local.get(t)}),{})},[t.THIS_SCRIPT]:{allSourceParams:()=>$((p||(p=S()),p))}};function _(e,t=null){const r=i[e],n=r.nameWords.join(""),a=r.nameWords.join("_").toUpperCase(),o=`inputSourceSelect âž” get value of ${n}.`;U(!0,o),L(`argument param: ${e}, uppercase join of nameWords: ${a}`);L(`${n}'s available sources are: ${P(r.availableSourcesSorted.map(e=>e.toLowerCase().replaceAll(/(?<=_)(.)/gi,(e,t)=>t.toUpperCase())).map(e=>e.charAt(0).toUpperCase()+e.slice(1)))}.`);
// Always search sources first
for(let e of r.availableSourcesSorted){const t=w[e];L(`Looking in ${e}`),Object.entries(t.allSourceParams()).forEach(([e,t])=>{L(`â¤· ${e} = ${t}`)});const n=N(r.nameWords,t.allSourceParams());if(n)return L(`Param:${a} was found âœ… in Source:${e} with value:${n}.`),U(!1,"1 "+o),String(n);L(`Param:${a} isn't in ${e}.`)}
// If not found, use currentValue if provided and valid, else default
if(L(`Param:${a} was not found âŒ in all sources.`),null!=t)try{return d({[e]:t},e),L(`Param:${a} was set to provided currentValue '${t}'.`),U(!1,"3 "+o),t}catch(e){}
// Fall back to default if exists
return"defaultValue"in r?(L(`Param:${a} was set to fallback default value '${r.defaultValue}'.`),U(!1,"4 "+o),r.defaultValue):(L(`Param:${a} has no default value, no current value, and isnt' in any source.`),U(!1,"5 "+o),null)}const E=Object.entries(i).map(([e,t])=>({...t,keyName:e})).filter(e=>e.availableSourcesSorted.includes("THIS_SCRIPT")).map(e=>e.keyName);class A{API_KEY="";CAMPAIGN_ID="";BASE_URL=i.BASE_URL.defaultValue??"";TRACE_ID=i.TRACE_ID.defaultValue??"";TTY_LEVEL=i.TTY_LEVEL.defaultValue??"";CHECKOUT_URL=i.CHECKOUT_URL.defaultValue??"";ttylvl=0;utmSource=null;constructor(){}update(){Object.entries(function(){const e=Object.keys(i),t={};for(const r of e){const e=_(r);t[r]=null==e?null:e}return t}()).forEach(([e,t])=>{this[e]=t}),isNaN(Number(this.TTY_LEVEL))?this.ttylvl=n[this.TTY_LEVEL.toLowerCase()]||0:this.ttylvl=Number(this.TTY_LEVEL),this.updateUtmSource()}updateUtmSource(){U(!0,"inputSourceSelect âž” utm_source"),L("UTM_Src: request to be updated");const e=function(e){T.groupCollapsed("Parse UTM Source");let t=location.search;t||(t=location.href.split("?")[1]),e&&e?.length>2&&(t=e);try{const e=new URLSearchParams(t).get(a);if(!e)return T.debug("No utm_source found in URL",location.href,{UTM_SOURCE_ID_PARAM:a,baseSearch:t}),null;
// Parse format: trace_id::api_key
const r=e.split("::");if(2!==r.length)return T.warn(`Invalid utm_source format: ${e} (expected: trace_id::api_key)`),null;const[n,o]=r;
// Basic validation
if(!n||!o)return T.warn(`Invalid utm_source parts: trace_id="${n}", api_key="${o}"`),null;
// URL decode in case it's encoded
const i=decodeURIComponent(n),s=decodeURIComponent(o);return T.log(`Parsed utm_source: trace_id="${i}", api_key="${s}"`),T.groupEnd(),{traceId:i,apiKey:s}}catch(e){return T.error("Failed to parse utm_source:",e),T.groupEnd(),null}}
/**
 * Sets or updates the utm_source parameter in the current URL
 * without reloading the page
 */();if(e?.traceId&&e.apiKey)this.TRACE_ID=e.traceId,this.API_KEY=e.apiKey,this.utmSource=`${this.TRACE_ID}::${this.API_KEY}`,L("UTM_Src: â¬‡ï¸ Obtained from URL",{trace_id:this.TRACE_ID,api_key:this.API_KEY});else if(L("UTM_Src: Not found in URL"),this.TRACE_ID&&this.API_KEY)this.utmSource=`${this.TRACE_ID}::${this.API_KEY}`,L("UTM_Src: âš™ï¸ Requirements to generate new utm_source are met"),L(`UTM_Src: âœ… New utm_source: ${this.utmSource}`);else{this.utmSource=null;let e=P(["TRACE_ID","API_KEY"].filter(e=>0==Boolean(this[e])));e=e+" "+(1===e.length?"is":"are"),L(`UTM_Src: can't generate new utm_source when ${e} empty.`)}U(!1,"inputSourceSelect âž” utm_source")}updateParamsThatMightNotHaveReadFromScriptElm(){const e=E.filter(e=>void 0===this[e]);e.forEach(e=>this.refresh(e));const t=e.map(e=>[e,this[e]]).filter(e=>null!=e[1]);if(t.length>0){L(`( ! ) updateParamsThatMightNotHaveReadFromScriptElm has found values for ${P(t.map(e=>String(e[1])))}`)}}updateScriptTiedParamIfNeeded(e){if(i[e].availableSourcesSorted.includes("THIS_SCRIPT")){let t=this[e];this.refresh(e),t!==this[e]&&L("( ! ) Update Script Tied Param If Needed - this was useful!")}}refresh(e,t=!1){let r=_(e,t?void 0:this[e]);
//@ts-ignore
r||(r=i[e].defaultValue),r||(r=""),this[e]=r}asObject(){
// this.updateParamsThatMightNotHaveReadFromScriptElm()
this.update();const e=this;return new Proxy({},{get(t,r){switch(r){case"apiKey":return e.getApiKey();case"campaignId":return e.getCampaignId();case"baseUrl":return e.getBaseUrl();case"traceId":return e.getTraceId();case"ttyLevel":return e.getTtyLevel();case"checkoutUrl":return e.getCheckoutUrl();case"utmSource":return e.getUtmSource();default:return}},set(t,r,n){switch(r){case"apiKey":return e.API_KEY=n,!0;case"campaignId":return e.CAMPAIGN_ID=n,!0;case"baseUrl":return e.BASE_URL=n,!0;case"traceId":return e.TRACE_ID=n,!0;case"ttyLevel":return e.TTY_LEVEL=n,!0;case"checkoutUrl":return e.CHECKOUT_URL=n,!0;case"utmSource":return e.utmSource=n,!0;default:return!1}}})}getApiKey(){
// console.trace(`Asked for API_KEY "${this.API_KEY}`)
// this.updateScriptTiedParamIfNeeded("API_KEY");
return this.API_KEY}setApiKey(e){e&&(this.API_KEY=e)}getCampaignId(){
// console.trace(`Asked for CAMPAIGN_ID "${this.CAMPAIGN_ID}`)
// this.updateScriptTiedParamIfNeeded("CAMPAIGN_ID");
return this.CAMPAIGN_ID}setCampaignId(e){e&&(this.CAMPAIGN_ID=e)}getBaseUrl(){
// this.updateScriptTiedParamIfNeeded("BASE_URL");
return this.BASE_URL}setBaseUrl(e){e&&(this.BASE_URL=e)}getTraceId(){
// console.trace(`Asked for TRACE_ID "${this.TRACE_ID}`)
// this.updateScriptTiedParamIfNeeded("TRACE_ID");
return this.TRACE_ID}setTraceId(e){e&&(this.TRACE_ID=e)}getTtyLevel(){
// this.updateScriptTiedParamIfNeeded("TTY_LEVEL");
return this.TTY_LEVEL}setTtyLevel(e){e&&(this.TTY_LEVEL=e)}getCheckoutUrl(){
// this.updateScriptTiedParamIfNeeded("CHECKOUT_URL");
return this.CHECKOUT_URL}setCheckoutUrl(e){e&&(this.CHECKOUT_URL=e)}
// console levels
getCanTTY(e){let t=e;if("string"==typeof t&&(t=n[t]),isNaN(+t)||null==t)return L(`Attemp to check if can log invalid log level '${t}'`),!1;return!!(this.ttylvl>=t)||(L(`Attempt to log '${t}' denied, current ttyLvl: '${this.ttylvl}'.`),!1)}static _instance;static get instance(){return this._instance??=new A}getSelf(){return this}getUtmSource(){return this.utmSource||(this.refresh("API_KEY"),this.refresh("TRACE_ID"),this.updateUtmSource()),this.utmSource}}const v=A.instance;
/* harmony default export */var b;!function(e){e.before=function(e,t){return(...r)=>e(...t(...r))},e.after=function(e,t){return(...r)=>t(e(...r))}}(b||(b={}));const I={error:["#ff4d4f","#2a0000"],warn:["#ffcc00","#2a2300"],info:["#29e3c0","#0f2220"],group:["inherit","inherit"],groupCollapsed:["inherit","inherit"],groupEnd:["inherit","inherit"],log:["#cccccc","#1e1e1e"],debug:["#7cf17c","#0f210f"],trace:["#9ba3ae","transparent"]},T=(()=>{const e=Object.keys(n),t=(...e)=>{},r=new Proxy({},{get:()=>t});
// is [console] object available?
try{if(!console)return r;for(let t of e)if("function"!=typeof console[t])return L(`trkiout â†’ ${console[t]} is not a function`),r}catch(e){L("trkiout â†’ failed E1:",e);try{v.getCanTTY("error")}catch(e){L("trkiout â†’ can not console error at all",e);
// can't console.error at all
}return r}
// internalDebug(`trkiout â†’ Passed Safeguard 1`);
// console wrapper
return new Proxy({},{get(r,n){
// internalDebug(`trkiout.${prop} â†’ ${typeof prop === "string"}, ${methods.includes(prop)}, ${!!console[prop]}, ${ParamSource.getCanTTY(prop)}`)
if("string"!=typeof n)return t;
// trkiout.[error|warn|log|info|debug|trace] only
if(!e.includes(n))return t;
// double check
const a=console[n];if(!a)return t;
// does it have permission to log?
if(!v.getCanTTY(n))return t;const[o,i]=I[n],s=`color:${o}; background:${i}; padding:1px 4px; border-radius:4px; font-weight:600; letter-spacing: 0.5px`;
// yes i can log that.
// internalDebug(`trkiout â†’ Passed Safeguard 2`);
return(...e)=>{
// let me prefix some stuff:
"string"==typeof e[0]?e[0]=`%c[TRAKI]%c ${e[0]}`:e=["%c[TRAKI]%c",...e],e=[e[0],s,"",...e.slice(1)],
//and log it.
a(...e)}}})})();
/**
 * Console[.log][.error][.info][.debug][etc] replacement, controlled by source param flags that enable it.
 */(()=>{const e=["false","close","wrong","dead","absent","positiv"],t=["y","1","sim","one","um"],r=["true","open","right","alive","present","unknown","null","undefined","negativ","nope","zero"],n=["n","0","on","nÃ£o","nao"]})();
/**
 * Sleep utility for retry delays
 */
function R(e){return new Promise(t=>setTimeout(t,e))}
/**
 * Debug function for when trkiout isnt available
 */function U(e,t){}
/**
 * Debug function for when trkiout isnt available
 */function L(...e){
// TODO: if (SOME_GLOBAL_ENVIRONMENT_FLAG_OR_WHATEVER) { console.debug(...arguments); }
let t="%c[IN-DEBUG]%c",r=e[0],n=e.slice(1),a=[],o=!1;"string"==typeof r?r=`${t} ${r}`:(a=[t,r,n],o=!0);a=[...o?[t]:[],r,"color:#3c3c3c; background:#BCD; padding:1px 4px; border-radius:4px; font-weight:600; letter-spacing:0.5px;","",n]}
/**
 * Gets a debounced version of a function.
 *
 * Debounce be like:
 * const dbncdFunc = getDebouncedFn(func);
 * dbncdFunc();
 * dbncdFunc();
 * dbncdFunc();
 * // 134 ms later:
 * dbncdFunc();
 * // 380 ms later:
 * dbncdFunc();
 * ...
 * // 400ms later:
 * func() is executed
 *
 *
 * // 490 ms later:
 * dbncdFunc()
 *
 * // 890ms later:
 * func() is executed
 */function C(e,t=400){let r;return function(...n){const a=this;return clearTimeout(r),new Promise((o,i)=>{r=setTimeout(()=>{try{o(e.apply(a,n))}catch(e){i(e)}},t)})}}function $(e){let t={};const r=e?.attributes;if(r)try{for(const e of r)t[e.name]=e.value}catch(t){T.error("Failed to iterate all attributes of element",e),T.trace(t)}return t}
/**
 * To Corrdinated Noun Phrase
 * Join a list of terms using seralized commas, but join them with the last
 * by connecting them with a conjunction term, like "or".
 * @param {string[]} list A list of words, like ["oranges", "apples", "bananas"].
 * @param {boolean|string} [isDisjunctive=false]
 *    false ðŸ š "and", true ðŸ š "or".
 *    This argument defines wether the items in the list define a set of different
 *    possibilities, aka an disjunctive list (and it should use the conjunction "or"),
 *    or if the terms are an aggregation, combination or conjuction of items, aka
 *    an conjunctive list (and then it should use the conjunction "and").
 *    Should you desire another kind of conjunction, like "nor", provide a string.
 * @param {boolean} [useOxfordComma=false]
 *    automatically applied when the provided list is exactly three terms.
 *    false: "we invited the doctors, trump  and obama" ðŸ š there are two doctors
 *    true:  "we invited the doctors, trump, and obama" ðŸ š two presidents
 *    Although this solves a specific case of ambiguity, in most of the scenarios
 *    it is not needed.
 * @returns {string} "oranges, apples and bananas"
 */function P(e,t=!1,r=void 0){if(!e)return"";const n=(Array.isArray(e)&&null!==e.length?e:[]).filter(e=>null!=e).map(e=>"function"==typeof e.toString?e.toString():String(e));if(0===n.length)return"";if(1===n.length)return n[0];if(2===n.length)return n[0]+" and "+n[1];(3===n.length&&null===r||void 0===r)&&(r=!0);return[e.slice(0,-1).join(", "),r?", ":" ",("string"==typeof t?t:["and","or"][+!!t])+" ",n[n.length-1]].join("")}function O(e,t){if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(e[r]!==t[r])return!1;return!0}const k=new RegExp("([^a-z0-9A-Z\n]+|(?<=[a-z])(?:\b|B)(?=[A-Z][a-z]+)|(?<=[a-z]{2,})(?:\b|B)(?=[A-Z]{2,})|(?<=[A-Z]{2,})(?:\b|B)(?=[a-z]{2,}))","g"),K="ï½œ";// Fullwidth Vertical Bar
function N(e,t){let r=[];for(const[n,a]of Object.entries(t)){const t=n.replace(/^data./gi,"").replaceAll(k,K),o=t.split(K),i=o.map(e=>e.toLowerCase());if(O(i,e)){L(`Tried all these: ${r.join(", ")} but none match with ${e.join("")}.`);return L("found!",{attrName:n,attrValue:a,attrNameMarked:t,attrWords:o,normalizedKeyWords:i}),a}r.push(n),r.length>10&&(L(`Tried all these: ${r.join(", ")} but none match with ${e.join("")}.`),r=[])}}
/**
 * Turns a glob pattern to an actual regexp of that glob.
 *
 * @param pattern glob string
 * @returns RegExp of the glob
 */
function D(e){let t=e.replace(/([.?+^$[\]\\(){}|\/-])/g,"\\$1").replace(/\*/g,".*");return new RegExp(t)}// ./src/functions/listenOutbound.ts
// =========================
//   MUTATION OBSERVER (links)
//   auto-UTM all anchors, existing + dynamic
// =========================
const M="data-traki-ed",j="data-traki-og";let F=location.href;function B(e){T.groupCollapsed("Listen to outbound events"),
// #region Observer
function({getFinalURL:e,dispatchEvent:t}){if(T.debug("Will listen to DOM changes"),!("MutationObserver"in window))return void T.error("MutationObserver doesnt exist in window");function r(t){if(!t||!t.getAttribute)return;const r=t.getAttribute("href");if(r&&(t.hasAttribute(j)||t.setAttribute(j,r),"trakied"!==t.getAttribute(M)))try{T.debug("Adding UTM to url of new <a href>");const n=new URL(r,location.href).toString(),a=e(n);a!==n&&(t.href=a),t.setAttribute(M,"trakied")}catch{
// ignore invalid URLs
}}
// initial pass
const n=document.querySelectorAll("a[href]");n.forEach(e=>r(e)),T.debug(`Initially found ${n.length} <a href> in this page.`);new MutationObserver(e=>{for(const t of e)"childList"===t.type?t.addedNodes.forEach(e=>{const t=e;1===t.nodeType&&("A"===t.tagName&&t.hasAttribute("href")&&r(t),t.querySelectorAll&&t.querySelectorAll("a[href]").forEach(e=>r(e)))}):"attributes"===t.type&&"href"===t.attributeName&&"A"===t.target.tagName&&r(t.target)}).observe(document.documentElement,{childList:!0,subtree:!0,attributes:!0,attributeFilter:["href"]}),T.debug("Listener for DOM Changes deployed.")}

// #endregion Observer
// =============================================================================
// #region Evt_Click

(e),function({getFinalURL:e,dispatchEvent:t}){T.debug("Will listen to <a href> clicks"),document.addEventListener("click",r=>{const n=r.target&&"function"==typeof r.target.closest&&r.target.closest("a[href]");if(!n)return;const a=n.getAttribute("href");T.debug(`There was a click in one of the observed anchor elements: <a href="${a||"??"}">`);const o=n.getAttribute(j)||a||n.href;let i;try{i=new URL(o,location.href).toString()}catch{i=o}const s=e(i);n.href=s,t("linkclick",i,{href:s,originalHref:o,domHref:a,
// target: a.target || "_self",
// domPath: getDomPath(a),
// text: getTextPreview(a),
// dataset: copyDataset(a),
modifiers:{ctrl:r.ctrlKey,meta:r.metaKey,shift:r.shiftKey,alt:r.altKey,button:r.button}})}),T.debug("Listener for anchor clicks deployed/")}(e),
// #endregion Evt_Click
// =============================================================================
// #region Evt_Form
function({getFinalURL:e,dispatchEvent:t}){T.debug("Will listen to form submission events"),document.addEventListener("submit",r=>{const n=r.target;if(!n||!n.action)return;T.debug(`There was a submission of a form: action="${n.action}"`);const a=n.action,o=e(a);n.action=o,t("FormSubmit",a,{action:o,originalAction:a,method:(n.method||"GET").toUpperCase()})}),T.debug("Listener for Form Submissions deployed")}

// #endregion Evt_Form
// =============================================================================
// #region PopState

(e),function({getFinalURL:e,dispatchEvent:t}){window.addEventListener("popstate",e=>{T.debug("An history state has been popped."),t("PopState",function(){const e=F;return F=location.href,e}(),e.state)}),T.debug("Listener for PopState deployed")}

// #endregion PopState
// =============================================================================
// #region Evt_Unload

(e),function({getFinalURL:e,dispatchEvent:t}){window.addEventListener("beforeunload",()=>{T.debug("Page is about to be unloaded."),t("BeforeUnload",location.href)}),window.addEventListener("unload",()=>{T.debug("Unloading page"),t("OnUnload",location.href)}),T.debug("Listener for [Before]Unload deployed")}

// #endregion PopState
// =============================================================================
// #region Evt_Unload

(e),function({getFinalURL:e,dispatchEvent:t}){
// polyfill();
if(T.debug("Will listen to navgation events"),window.navigation)return r();function r(){let t;window.navigation?.addEventListener("navigate",r=>{T.log("an Navigate event happened",r,r.destination.url,t);const n=window.navigation;if(!r?.destination?.url)return void T.debug("Navigation event has no destination URL.");try{r.destination.url=r?.destination?.url?.href??r?.destination?.url}catch(e){T.debug("Error trying to get navigation event's destination URL value.")}if(t==r.destination.url)return void T.debug("Event's destination URL is already patched.");r.preventDefault(),T.debug("Prevented original navigation");const a=e(r.destination.url),o=!r.destination.sameDocument;
// dispatchEvent(url, "Navigate"+event.navigationType)
if(t=a,o)return T.debug("Will navigate to patched url"),n.navigate(a,{history:"push"===r.navigationType?"push":"replace"===r.navigationType?"replace":"auto"});T.debug("Navigation destiny is same document, will pushState instead"),history.pushState({},"",a)})}window.addEventListener("navigationReady",r),T.debug("Listener for Navigation Events deployed")}

// #endregion Evt_Unload
(e),T.groupEnd()}// ./src/functions/patchToIntercept.ts
// =============================================================================
// #region Helpers
// function getFinalURL(destinyURL?: string | URL): string {
//   return addUTM(destinyURL);
// }
// function dispatchEvent(type: string, destinyURL?: string | URL, args?: unknown[]): void {
//   trkiout.log(`Dispatch Event from intercepted method: ${type}, ${destinyURL}, ${(args||[]).join(", ")}`);
//   return;
// }
// #endregion Helpers
// =============================================================================
// #region Intercept
function V(e){T.groupCollapsed("Patch global methods by Intercept");try{!
// #endregion Intercept
// =============================================================================
// #region WindowOpen
function({getFinalURL:e,dispatchEvent:t}){T.debug("Patching window.open()");const r=window.open;if(!r)return void T.error("Failed to patch window.open because there's no 'open'");window.open=function(n,a,o){return t("WindowOpen",n,{target:a,features:o}),r.call(this,e(n),a,o)},T.debug("Patched window.open.")}

// #endregion WindowOpen
// =============================================================================
// #region Location

// function patchLocation({ getFinalURL, dispatchEvent }: UrlEventParams) {
//   const proto = Object.getPrototypeOf(window.location);
//   const desc = Object.getOwnPropertyDescriptor(proto, "href");
//   if (desc && desc.configurable && desc.set && desc.get) {
//     Object.defineProperty(proto, "href", {
//       set(_url) {
//         dispatchEvent("LocationHrefSet", _url);
//         if (typeof desc.set === "function") {
//           return desc.set.call(this, getFinalURL(_url));
//         }
//       },
//       get() {
//         return desc.get!.call(this);
//       }
//     });
//   }
//   function wrap(name: "assign" | "replace") {
//     const orig = location[name];
//     if (typeof orig !== "function") return;
//     location[name] = function (_url: string) {
//       dispatchEvent(`Location${name.charAt(0)+name.slice(1)}`, _url);
//       return orig.call(this, getFinalURL(_url))
//     }
//   }
//   wrap("assign");
//   wrap("replace");
// };
/**
 * Intercepts window.location.href and related methods to add utm_source
 * Uses multiple strategies to ensure coverage across different browsers and scenarios
 */(e)}catch(e){return T.trace("Failed to patch WindowOpen",e),e}try{!function({getFinalURL:e,dispatchEvent:t}){T.debug("Patching location.href, location.assign, location.replace");let r=!1;
// Strategy 1: Try to intercept Location.prototype.href setter (most comprehensive)
try{const n=Object.getOwnPropertyDescriptor(Location.prototype,"href");if(n&&n.set&&n.configurable){const a=n.set;Object.defineProperty(Location.prototype,"href",{set:function(r){try{const n=e(r);T.debug(`[window.location.href] Intercepted: ${r} â†’ ${n}`),t("LocationSet",r),a.call(this,n)}catch(e){T.debug("[window.location.href] Interception failed:",e),a.call(this,r)}},get:n.get,enumerable:!0,configurable:!0}),r=!0,T.log("âœ… window.location.href setter intercepted (Location.prototype)")}}catch(e){T.debug("Failed to intercept Location.prototype.href:",e)}
// Strategy 2: Intercept window.location.assign (fallback/additional)
try{const r=window.location.assign;window.location.assign=function(n){try{const a=e(n);T.debug(`[window.location.assign] Intercepted: ${n} â†’ ${a}`),t("LocationAssign",n),r.call(this,a)}catch(e){return T.debug("[window.location.assign] Interception failed:",e),r.call(this,n)}},T.log("âœ… window.location.assign intercepted")}catch(e){T.debug("Failed to intercept window.location.assign:",e)}
// Strategy 3: Intercept window.location.replace (fallback/additional)
try{const r=window.location.replace;window.location.replace=function(n){try{const a=e(n);T.debug(`[window.location.assign] Intercepted: ${n} â†’ ${a}`),t("LocationReplace",n),r.call(this,a)}catch(e){return T.debug("[window.location.replace] Interception failed:",e),r.call(this,n)}},T.log("âœ… window.location.replace intercepted")}catch(e){T.debug("Failed to intercept window.location.replace:",e)}r||T.warn("âš ï¸ window.location.href not directly intercepted. Using fallback methods (assign/replace).")}

// #endregion Location
// =============================================================================
// #region History

(e)}catch(e){return T.trace("Failed to patch Location",e),e}try{!function({getFinalURL:e,dispatchEvent:t}){function r(r){T.debug(`Patching history.${r}()`);const n=history[r];"function"==typeof n?(history[r]=function(a,o,i){
// trkiout.log(`History.${name}(state, ${title}, ${_url} â‡¾ ${getFinalURL(_url as any)})`, state);
// @ts-ignore
return t(`History${r.charAt(0)+r.slice(1)}`,i,{state:a,title:o}),n.apply(this,[a,o,e(i)])},T.debug(`Patched history.${r} successfully.`)):T.error(`Failed to patch history.${r} - not a function`)}T.debug("Patching History"),r("pushState"),r("replaceState")}

// #endregion History
// =============================================================================
(e)}catch(e){return T.trace("Failed to patch History",e),e}T.groupEnd()}function H(e,t,r={}){const n={maxRetries:3,retryDelay:1e3,requestTimeout:5e3,method:"POST",apiKey:v.getApiKey(),baseUrl:v.getBaseUrl(),omitParams:[],...r||{}};n.headers={accept:"application/json","Content-Type":"application/json",Authorization:`Bearer ${n.apiKey}`,...r?.headers||{}};
// Separate 'name' from the rest of the data to construct proper payload
const{name:a,...o}=t;let i={...a?{name:a}:{},...o};Array.isArray(n.omitParams)&&(T.info("requestBody before omitParams: ",i),i=Object.entries(i).reduce((e,[t,r])=>n.omitParams?.includes(t)?e:{...e,[t]:r},{}),T.info("New requestBody after omitParams: ",i));const s=g(n,[["apiKey",d]]);if(!s.valid)return s.fields.forEach(({field:e,value:t,msg:r})=>T.error(r,t,e)),{abort:()=>{},response:new Promise(e=>e({success:!1,data:null,error:{msg:"Validation failed"}}))};const c=new AbortController,u=// ./src/types/api.ts
/**
 * Constructs a normalized URL by concatenating a base URL, version, and path segments.
 * It trims redundant slashes and ignores null/undefined/empty parts.
 *
 * @param {string | (string | number | null | undefined)[]} path
 *   The path string or array of path segments.
 *   When an array is provided, falsy items (`null`, `undefined`, `""`, `false`) are skipped.
 * @param {string | null | undefined} [baseURL=""]
 *   Optional base URL. Falls back to `ParamSource.getBaseUrl()` if falsy.
 * @param {TVersionParam} [version="v1"]
 *   API version prefix (e.g. `"v1"`, `"v2"`). Included in the URL after the base.
 * @returns {string}
 *   A fully composed, slash-normalized URL string.
 *
 * @example
 * getURL("/events")
 * // â†’ "https://example.com/v1/events"
 *
 * @example
 * getURL(["user", userId, "orders", orderId, "products"], API_URLS.orders, "v2")
 * // â†’ "https://orders.api/v2/user/123/orders/456/products"
 *
 * @example
 * getURL("user/123/orders/456/products")
 * // â†’ "https://example.com/v1/user/123/orders/456/products"
 *
 * @example
 * getURL(["products", productId, "images", hasImage && imageId]) âž” given hasImage is true
 * // â†’ "https://example.com/v1/products/42/images/7"
 *
 * @example
 * getURL(["products", productId, "images", hasImage && imageId]) âž” when there's no image
 * // â†’ "https://example.com/v1/products/42/images
 */
function(e,t="",r="v1"){return[t||v.getBaseUrl(),r].concat(Array.isArray(e)?e:[e]).filter(e=>null!=e&&""!==e).map(e=>String(e).replace(/^\/+|\/+$/g,"")).join("/")}(e,n.baseUrl);let l=null;const f=null==n.maxRetries?3:n.maxRetries,h=null==n.retryDelay?1e3:n.retryDelay;return{abort:()=>c.abort(),response:async function(){let e={success:!1,data:null,error:{msg:"unknown error"}};for(let t=0;t<=f;t++)try{const r=AbortSignal.timeout(n.requestTimeout||5e3),a=await fetch(u,{method:n.method,headers:n.headers,body:JSON.stringify(i),signal:AbortSignal.any([c.signal,r])});let o;try{o=await a.json()}catch(e){try{o=await a.text()}catch(e){o=e}}if(a.ok)return e={success:!0,error:null,data:o},o.data&&(e.data=o.data),o.data?.data&&(e.data=o.data.data),e;if(o.status>=400&&o.status<500&&(e={success:!1,error:{msg:`API request failed with status ${o.status}`,details:o,response:a},data:null}),
// Retry on server errors (5xx)
l=new Error(`Server error: ${o.status}`),t<f){await R(h*(t+1));// Exponential backoff
continue}}catch(r){
// Don't retry on abort/timeout for the last attempt
if(l=r instanceof Error?r:new Error("Unknown error"),t<f&&!l.message.includes("aborted")){e={success:!1,data:null,error:{msg:"DoRequest Failed all retries",details:{lastError:l,error:r}}},await R(h*(t+1));continue}}return e}()}}
/**
 * Record any Event from user interaction.
 *
 * This is the generic event seneder function and should be used as the only way to make requests that are about "create a record" and under the topic "event".
 * @param {string} eventName one of the accepted event names
 * @param {object} eventData object with the data that the event expects to receive.
 * @param {object} options{} Request behavior settings, only necessary in very specific scenarios.
 * @returns The data responded by the server if the request succeeds, or null if it fails.
 */async function G(e,t,r={}){const n=g({eventName:e,traceId:v.getTraceId()},[["eventName",d],["traceId",d]]);if(!n.valid)return n.fields.forEach(({field:e,value:t,msg:r})=>T.error(r,t,e)),new Promise(e=>e(null));const a=window.location.href,o={
// @ts-ignore
from:Y||document.referrer||void 0,
// @ts-ignore
to:a,
// @ts-ignore
title:document.title,viewport:{width:window.innerWidth,height:window.innerHeight},screen:{width:window.screen?.availWidth,height:window.screen?.availHeight,pxDepth:window.screen?.pixelDepth,colDepth:window.screen?.colorDepth,orientation:window.screen?.orientation?.type||"unknown",
// @ts-ignore
angle:window.screen?.angle||0,
// @ts-ignore
extended:window.screen?.isExtended},...t?.payload||{}};
// Payload (dynamic - can have any fields)
// Update last URL for next navigation
Y=a;
// Metadata (strict schema - only allowed fields)
const i={action_source:"WEBSITE",user_agent:navigator.userAgent,screen_height:window.screen?.availHeight,screen_width:window.screen?.availWidth,locale:navigator.language,page_url:a,page_referrer:document.referrer||void 0,...t?.metadata||{}},s={trace_id:v.getTraceId(),campaign_id:v.getCampaignId(),created_at:(new Date).toISOString(),name:e,payload:o,metadata:i};r.apiKey=v.getApiKey(),r.baseUrl=v.getBaseUrl();const c=H("/events",s,r),u=await c.response;return u.success?u.data:(T.error(`Failed to sendEvent ${e}: ${u.error.msg}`,{details:u.error.details}),null)}
// Store last URL to track navigation
let Y="";
/**
 * Track page view event
 */const W=C(async function(e,t){const r=window.location.href,n=Y||document.referrer||void 0,a={to:r,from:n,title:document.title,navigationMethod:e,...t||{}},o=await G("PageView",{payload:a,metadata:{}}),i=Boolean(o);return T.log(i?`Sent PageView: ${n} -> ${r}`:"Failed to send PageView event"),i},600);const x=C(async function(e,t){const r=window.location.href,n=Y||document.referrer||void 0,a={to:r,from:n,navigationMethod:e,...t||{}},o=await G("InitCheckout",{payload:a,metadata:{}}),i=Boolean(o);return T.log(i?`Sent InitCheckout: ${n} -> ${r}`:"Failed to send InitCheckout event"),i},600);
/**
 * Track before redirect event
 */ // ./src/export/traki.ts
try{Error.stackTraceLimit=100}catch(e){}
// TODO: intercept and add utm_source to
// - a[href]
// - window.open
// - form submit
// - redirect
function q(e,t){const r=u.session.get(e);r!=t?(u.session.set(e,t),T.log(`Updated ${e} in session storage, stored value "${r}" is outdated since new value "${t}" is found.`)):T.debug(`Did not update ${e} in session storage because the stored value "${r}" is the same as the new value "${t}"`)}
// /**
//  * Main Traki tracking initialization
//  */
// export async function traki() {
//   await sleep(400);
//   let config: ParamSourceObject = ParamSource.asObject();
//   let utmSrc = parseUtmSource();
//   for (let retry = 0; retry < 3; retry ++) {
//     if (config.apiKey && config.campaignId && utmSrc) {
//       break;
//     }
//     await sleep(300);
//     ParamSource.update();
//     config = ParamSource.asObject();
//     if (!utmSrc) {
//       utmSrc = parseUtmSource();
//     }
//   }
//   let missingParams = [];
//   if (utmSrc) {
//     trkiout.log([
//       `Found UTM_SOURCE in URL and it matches TRAKI's hashed data. Will override:`,
//       `- API_KEY was "${config.apiKey}" now is "${utmSrc.apiKey}"`,
//       `- TRACE_ID was "${config.traceId}" now is "${utmSrc.traceId}"`
//     ].join("\n"))
//     stores.session.set(STORAGE_KEYS.API_KEY, utmSrc.apiKey);
//     config.apiKey = utmSrc.apiKey;
//     stores.session.set(STORAGE_KEYS.TRACE_ID, utmSrc.traceId);
//     config.traceId = utmSrc.traceId;
//   } else {
//     trkiout.log("Did not found a valid UTM_SOURCE in url.");
//   }
//   if (!config.campaignId) { missingParams.push("campaign_id"); }
//   if (!config.apiKey) { missingParams.push("api_key"); }
//   if (!config.baseUrl) { missingParams.push("base_url"); }
//   if (!config.checkoutUrl) { missingParams.push("checkoutUrl"); }
//   if (missingParams.length > 0) {
//     trkiout.error(`Missing Params: ${missingParams.join(",")}. Cannot start event tracking`);
//     return;
//   } else {
//     trkiout.log("Required params ok");
//   }
//   const storedApiKey = stores.session.get(STORAGE_KEYS.API_KEY);
//   if (storedApiKey != config.apiKey) {
//     stores.session.set(STORAGE_KEYS.API_KEY, config.apiKey);
//     trkiout.log(`Updated ${STORAGE_KEYS.API_KEY} in session storage from "${storedApiKey}" to "${config.apiKey}"`);
//   }
//   const hasExistingTraceId = Boolean(config.traceId);
//   if (!hasExistingTraceId) {
//     trkiout.log('TraceID not found, generating one');
//     const isTraceCreated = await createTrace();
//     if (!isTraceCreated) {
//       trkiout.error('Failed to create traceId, cannot start event tracking');
//       return;
//     }
//   } else {
//     trkiout.log("TraceID: reused existing traceid '"+config.traceId+"'.")
//   }
//   // Initialize utm_source after trace_id is available
//   initUtmSource();
//   trkiout.log("Initialized successfully - PageView tracking enabled");
//   // Track initial page view
//   trackPageView();
//   // Track page view on every load/navigation
//   onLoad(() => {
//     trackPageView();
//   });
//   // Track page view on SPA navigation (React Router, etc)
//   onRedirect((state) => {
//     trkiout.log(`Navigation detected: ${state.from} -> ${state.to}`);
//     trackPageView();
//   });
//   // TODO: onFormSubmit
// }
// // -------------------------------------
!async function(){
// get params from first source where they're available
const t=v.asObject();T.debug([" says:","â”Œâ”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”","â”œâ”¼â”¼â”´â”´â”´â”´â”´â”´â”´â”¼â”¼â”¼â”´â”´â”´â”´â”´â”´â”´â”¼â”¼â”¼â”´â”´â”´â”´â”´â”´â”´â”¼â”¼â”¼â”´â”¼â”¼â”¼â”¼â”´â”´â”¼â”¼â”¼â”´â”´â”´â”´â”´â”´â”´â”¼â”¼â”¤","â”œâ”¼â”¼â”¬â”¬â” â”Œâ”¬â”¬â”¼â”¼â”¤ â”Œâ”¬â”¬â”¬â” â”œâ”¼â”¤ â”Œâ”¬â”¬â”¬â” â”œâ”¼â”¤ â”œâ”¼â”¼â”˜ â”¬â”¼â”¼â”¼â”¬â”¬â” â”Œâ”¬â”¬â”¼â”¼â”¤","â”œâ”¼â”¼â”¼â”¼â”¤ â”œâ”¼â”¼â”¼â”¼â”¤ â””â”´â”´â”´â”˜ â”œâ”¼â”¤ â””â”´â”´â”´â”˜ â”œâ”¼â”¤ â”œâ”˜ â”Œâ”¼â”¼â”¼â”¼â”¼â”¼â”¼â”¤ â”œâ”¼â”¼â”¼â”¼â”¤","â”œâ”¼â”¼â”¼â”¼â”¤ â”œâ”¼â”¼â”¼â”¼â”¤ â”Œâ”¬â” â”€â”¬â”¼â”¼â”¤ â”Œâ”¬â”¬â”¬â” â”œâ”¼â”¤   â”€â”´â”¼â”¼â”¼â”¼â”¼â”¼â”¼â”¤ â”œâ”¼â”¼â”¼â”¼â”¤","â”œâ”¼â”¼â”¼â”¼â”¤ â”œâ”¼â”¼â”¼â”¼â”¤ â”œâ”¼â”¼â” â””â”¼â”¼â”¤ â”œâ”¼â”¼â”¼â”¤ â”œâ”¼â”¤ â”œâ”¼â”¬  â””â”¼â”¼â”¼â”´â”´â”˜ â””â”´â”´â”¼â”¼â”¤","â”œâ”¼â”¼â”¼â”¼â”¼â”¬â”¼â”¼â”¼â”¼â”¼â”¼â”¬â”¼â”¼â”¼â”¼â”¬â”¬â”¼â”¼â”¼â”¬â”¼â”¼â”¼â”¼â”¼â”¬â”¼â”¼â”¼â”¬â”¼â”¼â”¼â”¼â”¼â”¬â”¼â”¼â”¼â”¬â”¬â”¬â”¬â”¬â”¬â”¬â”¼â”¼â”¤","â””â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”´â”˜"].join("\n ")),T.debug('TRAKI Version "1.2.0"\n\n'),
// log params at first bootstrap
T.groupCollapsed("Param Source Values"),T.log(`*apiKey:      "${t.apiKey}"`),T.log(`*campaignId:  "${t.campaignId}"`),T.log(`*baseUrl:     "${t.baseUrl}"`),T.log(`checkoutUrl:  "${t.checkoutUrl}"`),T.log(`ttyLevel:     "${t.ttyLevel}"`),T.log(`utmSource:    "${t.utmSource}"`),T.log(`traceId:      "${t.traceId}"`),T.groupEnd();
// verify obligatory initial params
let r=[];if(t.apiKey||r.push("api_key"),t.campaignId||r.push("campaign_id"),t.baseUrl||r.push("base_url"),r.length>0)return void T.error(`Missing Params: ${r.join(",")}. Cannot start event tracking`);
// create trace_id if none yet
if(!t.traceId){T.log("TraceID not found, generating one");const t=
// #endregion SelChange
// =============================================================================
// #region New_Trace
/**
 * Create a new trace via API
 */await async function(){const t=v.asObject();if(T.groupCollapsed("Will createTrace"),!t.campaignId||!t.apiKey)return T.error("Cannot create trace: missing campaign_id or api_key"),!1;const r=f(),n={campaign_id:t.campaignId,final_url:window.location.href,utm_source:r.utm_source,utm_medium:r.utm_medium,utm_campaign:r.utm_campaign,utm_term:r.utm_term,utm_content:r.utm_content,user_agent:navigator.userAgent,accept_language:navigator.language};T.log("tracePayload:",n);const a=H("traces",n,{...t||{},omitParams:["traceId","trace_id"]}),o=await a.response;if(!o.success)return T.error(`Failed to create trace: ${o?.error?.msg}`,{details:o?.error?.details}),T.groupEnd(),!1;T.log("doRequest('traces') response: ",o.data);let i=o.data?.trace?.id;
// @ts-ignore
// if (!createdTraceId) { createdTraceId = res.data?.data?.trace?.id; }
try{d({trace_id:i},"trace_id");
// validateUUID({ trace_id: createdTraceId}, "trace_id");
}catch(e){return e instanceof l?T.error(`Validation failed: ${e.message}`,{field:e.field,value:e.value}):T.error("Unknown error when validating",e),T.groupEnd(),!1}try{u.session.set(e.TRACE_ID,i)}catch(e){return T.error("Failed to store trace_id in SESSION_STORAGE",e),T.groupEnd(),!1}return v.setTraceId(i),v.getTraceId()===i?(T.debug("ParamSource successfully updated with new trace_id"),T.groupEnd(),!0):(T.error(`Trace ID mismatch after creation ParamSource:"${v.getTraceId()}", Provided by API: "${i}"`),T.groupEnd(),!1)}
// #endregion New_Trace
// =============================================================================
// #region End
// #endregion End
();if(!t)return void T.error("Failed to create traceId, cannot start event tracking");T.log("TraceID created successfully")}v.updateUtmSource(),T.groupCollapsed("Update storage if any value is new"),T.log(`[2] traceId:      "${t.traceId}"`),T.log(`[2] utmSource:    "${t.utmSource}"`),q(e.API_KEY,t.apiKey),q(e.CAMPAIGN_ID,t.campaignId),q(e.BASE_URL,t.baseUrl),q(e.TRACE_ID,t.traceId),q(e.CHECKOUT_URL,t.checkoutUrl),T.groupEnd();let n=[],a=[];var o;t.checkoutUrl&&(n=function(e){try{return e.split(",").map(e=>e.trim()).filter(Boolean).map(D)}catch(e){return T.error(e),[]}}(t.checkoutUrl),o=t.checkoutUrl,a=o.split(",").map(e=>e.trim()).filter(Boolean),T.debug("Configured matcher for checkout URL"));const i={getFinalURL:y,dispatchEvent:async function(e,r,o){T.groupCollapsed(`Dispatch Event '${e}'`);let i=r?r instanceof URL?r.toString():String(r):"";i||T.trace("Dispatch Event invoked with empty URL");const s=function(e){if(t.checkoutUrl){let r=function(e,t){for(const r of e)if(r.test(t))return!0;return!1}(n,e);r||a.some(e=>t.checkoutUrl.includes(e)||t.checkoutUrl===e)&&(T.debug(`URL ${e} matched as CHECKOUT url`),r=!0)}return T.debug(`URL ${e} isn't for checkout`),!1}(i),c=s?"InitiateCheckout":"PageView";T.log(`Dispatching Event "${c}" from subroutine "${e}"`,o);try{s?await x(e,o):(T.log(`Event of "${c}" sent successfully`),await W(e,o))}catch(e){T.error(`Failed to send ${c} event:`,e)}T.groupEnd()}};T.groupCollapsed("Patch, Listen and Set own UTM source"),V(i),B(i),function(e){T.debug("Will add utm_source to this page's own URL.");try{const t=y(new URL(window.location.href));window.history.replaceState(window.history.state,"",t.toString()),T.log(`utm_source set in this page's URL: "${e}"`)}catch(e){T.error("Failed to set utm_source in URL:",e)}}(t.utmSource),T.groupEnd()}()})();