<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, interactive-widget=resizes-content" />
    <title>N2BL - Get Related Apps</title>
    <link rel="stylesheet" href="/assets/nibol.css" />
    <script src="https://kit.fontawesome.com/40f0ec6d01.js" crossorigin="anonymous"></script>
    <script src="/assets/printObject.js"></script>
    
    <script>
      document.head.appendChild( (() => {
        const elm = document.createElement("script");
        elm.setAttribute("data-tty-lvl", "trace");
        elm.setAttribute("data-api_key", "tk_MHJWQkiy_01k968nhKaQkJY9819N9hG970Y");
        elm.setAttribute("data-campaign_id", "8d9ea73c-1db9-4ae7-9d56-2a6549569d46");
        const isDev = location.host.includes("localhost") || location.host.split(":")[1]?.length > 0;
        elm.setAttribute("data-base-url", isDev ? "http://localhost:8787/" : "https://api.traki.io/");
        elm.setAttribute("data-checkout-url", "*/hur/*");
        elm.setAttribute("src", "/traki.js?v="+Date.now());
        return elm;
      })() )
    </script>


    <style>
@import url('https://fonts.googleapis.com/css2?family=DM+Mono&display=swap');

:root {
  --max-width: 768px;
  --fg-color: #cdffe6;
  --bg-color: #001209;
}

#logs {
  font-family: "DM Mono", monospace;
  font-weight: 400;
  font-style: normal;
  font-optical-sizing: auto;
  font-feature-settings: "ss01" 0,"ss02" 1, "ss03" 1, "ss04" 0, "ss05" 1;
  position: relative;
  padding: 1rem;
  padding-inline-start: 1.2rem;
  font-size: 14px;
  color: var(--fg-color);
  background-color: var(--bg-color);
  display: flex;
  flex-direction: column;
  border-radius: 1rem;
  height: 75vh;
  overflow: auto;
  resize: vertical;
  min-height: 150px;
  max-height: 85vh;
}

#logs > p {
  margin: 0;
  display: inline-block;
  text-wrap-style: pretty;
  white-space-collapse: preserve;
  position: relative;
  border-bottom: 1px solid color-mix(in srgb, currentColor 30%, transparent 80%);
  padding: 0.4rem 0.5rem;
  box-sizing: border-box;
}

#logs > p:before {
  content: "â–¶";
  position: absolute;
  left: -1.3rem;
}

#n2bl-index {
  min-height: 100px;
  padding-bottom: 0;
}
#n2bl-index p {
  margin-bottom: 0;
}
    </style>
  </head>
  <body>
    <section class="section" id="n2bl-index">
      <div class="welcome-block">
        <h2>
          <a href="/N2BL/index.html" id="go-back">
            <i class="fa-solid fa-turn-up" style="transform:scaleX(-1)"></i>
          </a>
          <i class="fa-solid fa-star-of-life"></i> Related Apps
        </h2>
        <p>An web experiment to see if a browser page can list installed apps on the user's device.</p>
      </div>
    </section>

    <section class="section">
      <div class="container">
        <div id="logs"></div>
      </div>
    </section>

    <section class="section"></section>

    <script>
console.clear();

const $logs = document.getElementById("logs");

function log() {
  const content = Array.from(arguments).join("\n");
  console.log(content);
  $logs.appendChild((() => {
    const p = document.createElement("p");
    p.innerText = content;
    return p;
  })());
}

// usage:
// probeScheme('whatsapp://send?text=hi').then(installed => console.log(installed));
async function probeScheme(uri, timeout = 1200) {
  return new Promise(resolve => {
    const t0 = Date.now();
    let done = false;
    const onVis = () => {
      if (document.hidden) finish(true);
    };
    function finish(found) {
      if (done) return;
      done = true;
      cleanup();
      resolve(found);
    }
    const timer = setTimeout(()=> {
      // if page didn't lose visibility, assume app not installed
      finish(false);
    }, timeout);
    function cleanup() {
      clearTimeout(timer);
      document.removeEventListener('visibilitychange', onVis);
    }
    document.addEventListener('visibilitychange', onVis);
    // attempt to open:
    const iframe = document.createElement('iframe');
    iframe.style.display = 'none';
    document.body.appendChild(iframe);
    try { iframe.src = uri; } catch(e) { finish(false); }
    // cleanup iframe in timeout or on finish
    setTimeout(() => { iframe.remove(); }, timeout + 500);
  });
}

function formatBytes(x, locale = "en") {
  if (!Number.isFinite(x)) return "NaN";
  const units = ["B", "KB", "MB", "GB", "TB", "PB"];
  const i = Math.floor(Math.log(x) / Math.log(1024));
  const value = x / Math.pow(1024, i);
  return new Intl.NumberFormat(locale, {
    maximumFractionDigits: 2
  }).format(value) + " " + units[i];
}

async function tryGetApps() {  

  try {
    log(navigator.deviceMemory ? `ðŸ’¾ Device Memory: ${navigator.deviceMemory} GB` : "ðŸ’¾ Device Memory: Not available");
  } catch (e) {
    log("Failed to get Device Memory:", e);
  }
  try {
    log(navigator.hardwareConcurrency ? `ðŸ§‡ CPU Cores: ${navigator.hardwareConcurrency} GB` : "ðŸ§‡ CPU Cores: Not available");
  } catch (e) {
    log("Failed to get CPU Cores:", e);
  }
  try {
    log(`â˜• Java Support: ${navigator.javaEnabled() ? `Enabled` : `Disabled`}`);
  } catch (e) {
    log("Failed to get Java Support:", e);
  }
  try {
    log(`ðŸª Cookie Support: ${navigator.cookieEnabled ? `Enabled` : `Disabled`}`);
  } catch (e) {
    log("Failed to get Cookie Support:", e);
  }
  try {
    const ls = await navigator.keyboard.getLayoutMap();
    log(`âŒ¨ï¸ Keyboard Layout Size: ${ls.size}`);
  } catch (e) {
    log("Failed to get Keyboard Layout Size:", e);
  }
  try {
    log(`ðŸ‘† Max Touches: ${navigator.maxTouchPoints}`);
  } catch (e) {
    log("Failed to get Max Touch Points:", e);
  }
  try {
    log(`âš™ï¸ Product: ${navigator.product} v${navigator.productSub}`);
  } catch (e) {
    log("Failed to get Product and ProductSub", e);
  }
  try {
    log(`âš™ï¸ Vendor: ${navigator.vendor} v${navigator.vendorSub}`);
  } catch (e) {
    log("Failed to get Vendor and VendorSub", e);
  }
  try {
    let dnt = navigator.doNotTrack;
    if (typeof navigator.doNotTrack === "function") {
      dnt = navigator.doNotTrack();
    }
    if (dnt === "1" || dnt === "yes" || dnt === 1) {
      log(`âš™ï¸ DoNotTrack: 1, Do Not Track`);
    } else if (dnt === "0" || dnt === "no" || dnt === 0) {
      log(`âš™ï¸ DoNotTrack: 0, Yes Track`);
    } else {
      log(`âš™ï¸ DoNotTrack: ?, Unspecified`);
    }
  } catch (e) {
    log("Failed to get Do Not Track value", e);
  }


  try {
    const estimate = await navigator.storage.estimate();
    const { quota, usage, usageDetails } = estimate;
    const usagePc = ((usage / quota) * 100).toFixed(3) + "%";
    const strQuota = formatBytes(quota);
    const strUsage = formatBytes(usage);
    log(`ðŸ—„ï¸ Storage Estimate: Quota ${strQuota}, Usage: ${strUsage} | ${usagePc}`);
  } catch (e) {
    log("Failed to get Storage Estimate:", e);
  }

  try {
    const con = navigator.connection;
    let conLog = [`ðŸ›œ Connection: `];
    if ("saveData" in con && con.saveData) conLog.push("[Data Saver ON] ");
    if ("effectiveType" in con) conLog.push(con.effectiveType + ", ");
    if ("downlink" in con) {
      const dnlnk = con.downlink;
      if (dnlnk == 10) {
        conLog.push(`Downlink: ${con.downlink}Mbps (likely browser obfuscated), `);
      } else {
        conLog.push(`Downlink: ${con.downlink}Mbps, `);
      }
    }
    if ("downlinkMax" in con) conLog.push(`Max Downlink: ${con.downlinkMax}Mbps, `);
    if ("rtt" in con) conLog.push(`Round Trip Time (RTT): ${con.rtt} ms`);

    log(conLog.join(""));
  } catch (e) {
    log("Failed to get Connection Data:", e);
  }
  
  try {
    const btPermission = await navigator.permissions.query({ name: "bluetooth" });
    const btAvailability = await navigator.bluetooth.getAvailability();
    log(`áš¼á›’ Bluetooth: Permission ${btPermission ? 'âœ…' : 'âŒ'}, Availability ${btAvailability ? 'âœ…' : 'âŒ'}, `)
  } catch (e) {
    log("Failed to get Connection Data:", e);
  }

  try {
    const battery = await navigator.getBattery();
    log(
      `ðŸ”‹ Battery Info: ${battery.charging ? "Charging" : "Discharging"} at level ${battery.level}`,
      `chargingTime: ${battery.chargingTime}, dischargingTime: ${battery.dischargingTime}`
    )
  } catch (e) {
    log("Failed to getBattery:", e);
  }

  try {
    const uadata = navigator.userAgentData;
    log(`ðŸ›  User Agent Data: ${uadata.ismobile ? "Mobile" : "Desktop"}, ${uadata.platform}`);
    uadata.brands.forEach(brand => {
      log(` - ${brand.brand} v${brand.version}`);
    });
  } catch (e) {
    log("Failed to get User Agent Data:", e);
  }


  log("âŒ£âŒ¢".repeat(8));


  if ('getInstalledRelatedApps' in navigator) {
    try {
      //{platform, id, url}
      const apps = await navigator.getInstalledRelatedApps();
      log("Got apps via getInstalledRelatedApps successfully!");
      log(`Found ${apps.length} installed related apps:`);
      apps.forEach((app, idx) => {
        const didx = String(idx).padStart(3, "0");
        log(
          `- ["${didx}"]  ID: ${app.id}`,
          `        URL: ${app.url}`,
          `   PLATFORM: ${app.platform}`,
        );
      });
    } catch (e) {
      log("Error trying to get 'getInstalledRelatedApps':", e);
    }
  } else {
    log("'getInstalledRelatedApps' is not available in this browser.");
  }
    
  // log("------","","Will try to identify installed apps via janky trick.");

  const prbApps = [
    {name:'WhatsApp', probe: 'whatsapp://send?text=hi', intent: 'intent://send/#Intent;package=com.whatsapp;scheme=whatsapp;end'},
    {name:'Telegram', probe: 'tg://msg?text=hi', intent: 'intent://msg/#Intent;package=org.telegram.messenger;scheme=tg;end'},
    // add others
  ];

  // prbApps.forEach(async (app) => {
  //   const installed = await probeScheme(app.probe);
  //   log(
  //     `${app.name} is ${installed ? "" : "NOT "}installed`,
  //   );
  // });

  // log("Done probing for related apps.");
}

tryGetApps();
    </script>
  </body>
</html>
