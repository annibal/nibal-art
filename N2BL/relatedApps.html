<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, interactive-widget=resizes-content" />
    <title>N2BL - Get Related Apps</title>
    <link rel="stylesheet" href="/assets/nibol.css" />
    <script src="https://kit.fontawesome.com/40f0ec6d01.js" crossorigin="anonymous"></script>
    <script src="/assets/printObject.js"></script>
    
    <script>
      document.head.appendChild( (() => {
        const elm = document.createElement("script");
        elm.setAttribute("data-tty-lvl", "trace");
        elm.setAttribute("data-api_key", "tk_MHJWQkiy_01k968nhKaQkJY9819N9hG970Y");
        elm.setAttribute("data-campaign_id", "8d9ea73c-1db9-4ae7-9d56-2a6549569d46");
        const isDev = location.host.includes("localhost") || location.host.split(":")[1]?.length > 0;
        elm.setAttribute("data-base-url", isDev ? "http://localhost:8787/" : "https://api.traki.io/");
        elm.setAttribute("data-checkout-url", "*/hur/*");
        elm.setAttribute("src", "/traki.js?v="+Date.now());
        return elm;
      })() )
    </script>


    <style>
@import url('https://fonts.googleapis.com/css2?family=DM+Mono&display=swap');

:root {
  --max-width: 768px;
  --fg-color: #cdffe6;
  --bg-color: #001209;
}

#logs {
  font-family: "DM Mono", monospace;
  font-weight: 400;
  font-style: normal;
  font-optical-sizing: auto;
  font-feature-settings: "ss01" 0,"ss02" 1, "ss03" 1, "ss04" 0, "ss05" 1;
  position: relative;
  padding: 1rem;
  padding-inline-start: 1.2rem;
  font-size: 14px;
  color: var(--fg-color);
  background-color: var(--bg-color);
  display: flex;
  flex-direction: column;
  border-radius: 1rem;
  height: 75vh;
  overflow: auto;
  resize: vertical;
  min-height: 150px;
  max-height: 85vh;
}

#logs > p {
  margin: 0;
  display: inline-block;
  text-wrap-style: pretty;
  white-space-collapse: preserve;
  position: relative;
  border-bottom: 1px solid color-mix(in srgb, currentColor 30%, transparent 80%);
  padding: 0.4rem 0.5rem;
  box-sizing: border-box;
}

#logs > p:before {
  content: "â–¶";
  position: absolute;
  left: -1.3rem;
}

#n2bl-index {
  min-height: 100px;
  padding-bottom: 0;
}
#n2bl-index p {
  margin-bottom: 0;
}
    </style>
  </head>
  <body>
    <section class="section" id="n2bl-index">
      <div class="welcome-block">
        <h2>
          <a href="/N2BL/index.html" id="go-back">
            <i class="fa-solid fa-turn-up" style="transform:scaleX(-1)"></i>
          </a>
          <i class="fa-solid fa-star-of-life"></i> Related Apps
        </h2>
        <p>An web experiment to see if a browser page can list installed apps on the user's device.</p>
      </div>
    </section>

    <section class="section">
      <div class="container">
        <div id="logs"></div>
      </div>
    </section>

    <section class="section"></section>

    <script>
console.clear();

const $logs = document.getElementById("logs");

function log() {
  const content = Array.from(arguments).join("\n");
  console.log(content);
  $logs.appendChild((() => {
    const p = document.createElement("p");
    p.innerText = content;
    return p;
  })());
}


function formatBytes(x, locale = "en") {
  if (!Number.isFinite(x)) return "NaN";
  const units = ["B", "KB", "MB", "GB", "TB", "PB"];
  const i = Math.floor(Math.log(x) / Math.log(1024));
  const value = x / Math.pow(1024, i);
  return new Intl.NumberFormat(locale, {
    maximumFractionDigits: 2
  }).format(value) + " " + units[i];
}

tryGetAllInfos();

async function tryGetAllInfos() {  

  try {
    log(navigator.deviceMemory ? `ðŸ’¾ Device Memory: ${navigator.deviceMemory} GB` : "ðŸ’¾ Device Memory: Not available");
  } catch (e) {
    log("Failed to get Device Memory:", e);
  }
  try {
    log(navigator.hardwareConcurrency ? `ðŸ§‡ CPU Cores: ${navigator.hardwareConcurrency} GB` : "ðŸ§‡ CPU Cores: Not available");
  } catch (e) {
    log("Failed to get CPU Cores:", e);
  }
  try {
    log(`â˜• Java Support: ${navigator.javaEnabled() ? `Enabled` : `Disabled`}`);
  } catch (e) {
    log("Failed to get Java Support:", e);
  }
  try {
    log(`ðŸª Cookie Support: ${navigator.cookieEnabled ? `Enabled` : `Disabled`}`);
  } catch (e) {
    log("Failed to get Cookie Support:", e);
  }
  try {
    const ls = await navigator.keyboard.getLayoutMap();
    log(`âŒ¨ï¸ Keyboard Layout Size: ${ls.size}`);
  } catch (e) {
    log("Failed to get Keyboard Layout Size:", e);
  }
  try {
    log(`ðŸ‘† Max Touches: ${navigator.maxTouchPoints}`);
  } catch (e) {
    log("Failed to get Max Touch Points:", e);
  }
  try {
    log("ðŸ“¡ Pointer Capabilities:");
    log(` - hover: ${matchMedia("(hover: hover)").matches}`);
    log(` - any-hover: ${matchMedia("(any-hover: hover)").matches}`);
    log(` - pointer: ${matchMedia("(pointer: fine)").matches}`);
    log(` - any-pointer: ${matchMedia("(any-pointer: fine)").matches}`);
  } catch(e){ log("Pointer failed:", e); }
  try {
    log(`âš™ï¸ Product: ${navigator.product} v${navigator.productSub}`);
  } catch (e) {
    log("Failed to get Product and ProductSub", e);
  }
  try {
    log(`âš™ï¸ Vendor: ${navigator.vendor} v${navigator.vendorSub}`);
  } catch (e) {
    log("Failed to get Vendor and VendorSub", e);
  }
  try {
    let dnt = navigator.doNotTrack;
    if (typeof navigator.doNotTrack === "function") {
      dnt = navigator.doNotTrack();
    }
    if (dnt === "1" || dnt === "yes" || dnt === 1) {
      log(`âš™ï¸ DoNotTrack: 1, Do Not Track`);
    } else if (dnt === "0" || dnt === "no" || dnt === 0) {
      log(`âš™ï¸ DoNotTrack: 0, Yes Track`);
    } else {
      log(`âš™ï¸ DoNotTrack: ?, Unspecified`);
    }
  } catch (e) {
    log("Failed to get Do Not Track value", e);
  }


  try {
    const estimate = await navigator.storage.estimate();
    const { quota, usage, usageDetails } = estimate;
    const usagePc = ((usage / quota) * 100).toFixed(3) + "%";
    const strQuota = formatBytes(quota);
    const strUsage = formatBytes(usage);
    log(`ðŸ—„ï¸ Storage Estimate: Quota ${strQuota}, Usage: ${strUsage} | ${usagePc}`);
  } catch (e) {
    log("Failed to get Storage Estimate:", e);
  }

  try {
    const con = navigator.connection;
    let conLog = [`ðŸ›œ Connection: `];
    if ("saveData" in con && con.saveData) conLog.push("[Data Saver ON] ");
    if ("effectiveType" in con) conLog.push(con.effectiveType + ", ");
    if ("downlink" in con) {
      const dnlnk = con.downlink;
      if (dnlnk == 10) {
        conLog.push(`Downlink: ${con.downlink}Mbps (likely browser obfuscated), `);
      } else {
        conLog.push(`Downlink: ${con.downlink}Mbps, `);
      }
    }
    if ("downlinkMax" in con) conLog.push(`Max Downlink: ${con.downlinkMax}Mbps, `);
    if ("rtt" in con) conLog.push(`Round Trip Time (RTT): ${con.rtt} ms`);

    log(conLog.join(""));
  } catch (e) {
    log("Failed to get Connection Data:", e);
  }
  
  try {
    const btPermission = await navigator.permissions.query({ name: "bluetooth" });
    const btAvailability = await navigator.bluetooth.getAvailability();
    log(`áš¼á›’ Bluetooth: Permission ${btPermission ? 'âœ…' : 'âŒ'}, Availability ${btAvailability ? 'âœ…' : 'âŒ'}, `)
  } catch (e) {
    log("Failed to get Connection Data:", e);
  }

  try {
    const battery = await navigator.getBattery();
    log(
      `ðŸ”‹ Battery Info: ${battery.charging ? "Charging" : "Discharging"} at level ${battery.level}`,
      `chargingTime: ${battery.chargingTime}, dischargingTime: ${battery.dischargingTime}`
    )
  } catch (e) {
    log("Failed to getBattery:", e);
  }

  try {
    const uadata = navigator.userAgentData;
    log(`ðŸ“› User Agent Data: ${uadata.ismobile ? "Mobile" : "Desktop"}, ${uadata.platform}`);
    uadata.brands.forEach(brand => {
      log(` - ${brand.brand} v${brand.version}`);
    });
  } catch (e) {
    try {
      log(`ðŸ“› UserAgent (fallback): ${navigator.userAgent}`);
    } catch (e) {
      log("Failed to get User Agent Data:", e);
    }
  }
  try {
    log("ðŸ§© High Entropy UA:");
    if (navigator.userAgentData?.getHighEntropyValues) {
      const hi = await navigator.userAgentData.getHighEntropyValues(["architecture","model","platformVersion","fullVersionList"]);
      log(JSON.stringify(hi, null, 2));
    } else log(" - Not supported");
  } catch(e){ log("UA entropy failed:", e); }

  // try {
  //   log("ðŸ“‹ Clipboard Types Supported:");
  //   if (navigator.clipboard?.read) {
  //     const items = await navigator.clipboard.read();
  //     items.forEach((i,n)=> log(` - item[${n}] types: ${i.types.join(", ")}`));
  //   } else log("Clipboard read not available");
  // } catch(e){ log("Clipboard read failed:", e); }
  
  try {
    log(`ðŸŒ Languages: ${navigator.languages.join(", ")}`);
  } catch(e){ log("Failed Languages:", e); }

  try {
    log(`ðŸ•’ Timezone: ${Intl.DateTimeFormat().resolvedOptions().timeZone}`);
  } catch(e){ log("Failed Timezone:", e); }

  try {
    log(`ðŸ“ Screen: ${screen.width}x${screen.height} @${screen.pixelDepth}bit`);
    log(`ðŸ“ Avail Screen: ${screen.availWidth}x${screen.availHeight}`);
  } catch(e){ log("Failed Screen:", e); }

  try {
    log(`ðŸªŸ Viewport: ${window.innerWidth}x${window.innerHeight}`);
    log(`ðŸªŸ Scrollbars: ${window.innerWidth - document.documentElement.clientWidth}px`);
  } catch(e){ log("Failed Viewport:", e); }

  try {
    const ratio = window.devicePixelRatio;
    log(`ðŸ”Ž Pixel Ratio: ${ratio}`);
  } catch(e){ log("Failed Pixel Ratio:", e); }

  try {
    log(`ðŸ§­ Orientation: ${(screen.orientation || {}).type}`);
  } catch(e){ log("Failed Orientation:", e); }
  
  try {
    log("ðŸ–¼ Fullscreen API:");
    log(` - enabled: ${document.fullscreenEnabled}`);
  } catch(e){ log("Fullscreen failed:", e); }

  try {
    log("ðŸ“± Form-Factors:");
    log(` - prefers-contrast more: ${matchMedia("(prefers-contrast: more)").matches}`);
    log(` - forced-colors active: ${matchMedia("(forced-colors: active)").matches}`);
  } catch(e){ log("Form-factor failed:", e); }

  try {
    log(`ðŸŽ¨ Color Scheme: ${matchMedia("(prefers-color-scheme: dark)").matches ? "Dark" : "Light"}`);
  } catch(e){ log("Failed Color Scheme:", e); }

  try {
    log(`ðŸŽ¬ Reduced Motion: ${matchMedia("(prefers-reduced-motion: reduce)").matches ? "Reduce" : "Normal"}`);
  } catch(e){ log("Failed Reduced Motion:", e); }

  try {
    log("ðŸŽ¨ HDR Support:");
    log(` - color-gamut p3: ${matchMedia("(color-gamut: p3)").matches}`);
    log(` - color-gamut rec2020: ${matchMedia("(color-gamut: rec2020)").matches}`);
  } catch(e){ log("HDR failed:", e); }

  try {
    log(`ðŸ–¥ Platform: ${navigator.platform}`);
  } catch(e){ log("Failed Platform:", e); }

  try {
    const perms = ["geolocation","notifications","clipboard-read","clipboard-write","camera","microphone","bluetooth","background-sync","gyroscope","accelerometer","magnetometer"];
    for (const p of perms) {
      try {
        const q = await navigator.permissions.query({name:p});
        logs.push(`${p}: ${q.state}`);
      } catch (err) {
        logs.push(`${p}: Failed with error ${e}`);
      }
    }
    log("ðŸ” Permissions dump: " + logs.join(", "));
  } catch(e){ log("Permissions failed:", e); }

  try {
    log(`ðŸ“„ MIME Types:`); 
    for (const m of navigator.mimeTypes) log(` - ${m.type}`);
  } catch(e){ log("Failed MIME Types:", e); }

  try {
    log(`ðŸ§© Plugins:`); 
    for (const p of navigator.plugins) log(` - ${p.name}`);
  } catch(e){ log("Failed Plugins:", e); }

  try {
    const canvas = document.createElement("canvas");
    const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
    if (gl) {
      const dbg = gl.getExtension("WEBGL_debug_renderer_info");
      const vendor = dbg ? gl.getParameter(dbg.UNMASKED_VENDOR_WEBGL) : "N/A";
      const renderer = dbg ? gl.getParameter(dbg.UNMASKED_RENDERER_WEBGL) : "N/A";
      log(`ðŸŽ® GPU Vendor: ${vendor}`);
      log(`ðŸŽ® GPU Renderer: ${renderer}`);
    } else {
      log("ðŸŽ® WebGL unavailable");
    }
  } catch(e){ log("Failed WebGL:", e); }

  try {
    log("ðŸ•¹ WebGL2 Info:");
    const canvas = document.createElement("canvas");
    const gl = canvas.getContext("webgl2");
    if (gl) {
      const dbg = gl.getExtension("WEBGL_debug_renderer_info");
      log(` - Renderer: ${dbg ? gl.getParameter(dbg.UNMASKED_RENDERER_WEBGL) : "N/A"}`);
      log(` - Vendor: ${dbg ? gl.getParameter(dbg.UNMASKED_VENDOR_WEBGL) : "N/A"}`);
      log(` - Max Texture Size: ${gl.getParameter(gl.MAX_TEXTURE_SIZE)}`);
      log(` - Max Vertex Textures: ${gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS)}`);
      log(` - Extensions: ${gl.getSupportedExtensions().join(", ")}`);
    } else log(" - WebGL2 unavailable");
  } catch(e){ log("WebGL2 failed:", e); }

  try {
    log(`ðŸŒ Do Not Disturb (approx): ${matchMedia("(prefers-reduced-motion: reduce)").matches}`);
  } catch(e){ log("Failed:", e); }

  try {
    log("ðŸŽ¥ Media Devices:");
    const devs = await navigator.mediaDevices.enumerateDevices();
    devs.forEach(d => log(` - ${d.kind}: ${d.deviceId} (${d.label || "no-label"})`));
  } catch(e){ log("MediaDevices failed:", e); }

  try {
    log("ðŸ”§ Supported Constraints:");
    const c = navigator.mediaDevices.getSupportedConstraints();
    Object.keys(c).forEach(k => log(` - ${k}: ${c[k]}`));
  } catch(e){ log("Constraints failed:", e); }

  try {
    log("ðŸŽ® Gamepads:");
    const pads = navigator.getGamepads?.() || [];
    pads.forEach((p,i)=> p && log(` - GP${i}: ${p.id}`));
  } catch(e){ log("Gamepads failed:", e); }

  try {
    log("ðŸŽ§ AudioContext entropy:");
    const ctx = new AudioContext();
    const osc = ctx.createOscillator();
    const analyser = ctx.createAnalyser();
    osc.connect(analyser);
    osc.start(0);
    const arr = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteFrequencyData(arr);
    log(` - Audio hash: ${arr.slice(0,16).join(",")}`);
    osc.stop();
  } catch(e){ log("Audio failed:", e); }

  try {
    log("ðŸ–Œ Canvas fingerprint:");
    const c = document.createElement("canvas");
    const g = c.getContext("2d");
    g.textBaseline = "top";
    g.font = "14px 'Arial'";
    g.fillStyle = "#f60";
    g.fillText("fingerprinting", 2, 2);
    const url = c.toDataURL();
    log(` - Canvas hash: ${btoa(url).slice(0,32)}`);
  } catch(e){ log("Canvas failed:", e); }

  try {
    log("ðŸ” Zoom Level:");
    log(` - devicePixelRatio: ${window.devicePixelRatio}`);
    log(` - estimated zoom: ${(window.outerWidth / window.innerWidth).toFixed(2)}`);
  } catch(e){ log("Zoom failed:", e); }

  try {
    log("ðŸ…° Font Enumeration (if supported):");
    if ('fonts' in navigator && navigator.fonts.query) {
      const fonts = await navigator.fonts.query();
      for await (const f of fonts) log(` - ${f.postscriptName}`);
    } else log(" - Not supported");
  } catch(e){ log("Fonts failed:", e); }

  try {
    log("âŒ¨ Virtual Keyboard:");
    const vk = navigator.virtualKeyboard;
    log(` - overlaysContent: ${vk?.overlaysContent}`);
  } catch(e){ log("VK failed:", e); }

  try {
    log("ðŸ”‹ IdleDetector supported: " + ("IdleDetector" in window));
  } catch(e){ log("IdleDetector failed:", e); }

  try {
    log("ðŸ‰ WebGPU:");
    if (navigator.gpu) {
      const adapter = await navigator.gpu.requestAdapter();
      log(` - Vendor: ${adapter.vendor}`);
      log(` - Architecture: ${adapter.architecture}`);
      log(` - Features: ${[...adapter.features].join(", ")}`);
    } else log(" - WebGPU unavailable");
  } catch(e){ log("WebGPU failed:", e); }

  log("âŒ£âŒ¢".repeat(8));


  if ('getInstalledRelatedApps' in navigator) {
    try {
      //{platform, id, url}
      const apps = await navigator.getInstalledRelatedApps();
      log("Got apps via getInstalledRelatedApps successfully!");
      log(`Found ${apps.length} installed related apps:`);
      apps.forEach((app, idx) => {
        const didx = String(idx).padStart(3, "0");
        log(
          `- ["${didx}"]  ID: ${app.id}`,
          `        URL: ${app.url}`,
          `   PLATFORM: ${app.platform}`,
        );
      });
    } catch (e) {
      log("Error trying to get 'getInstalledRelatedApps':", e);
    }
  } else {
    log("'getInstalledRelatedApps' is not available in this browser.");
  }
    
  // log("------","","Will try to identify installed apps via janky trick.");

  const prbApps = [
    {name:'WhatsApp', probe: 'whatsapp://send?text=hi', intent: 'intent://send/#Intent;package=com.whatsapp;scheme=whatsapp;end'},
    {name:'Telegram', probe: 'tg://msg?text=hi', intent: 'intent://msg/#Intent;package=org.telegram.messenger;scheme=tg;end'},
    // add others
  ];

  // prbApps.forEach(async (app) => {
  //   const installed = await probeScheme(app.probe);
  //   log(
  //     `${app.name} is ${installed ? "" : "NOT "}installed`,
  //   );
  // });

  // log("Done probing for related apps.");
  
  // // usage:
  // // probeScheme('whatsapp://send?text=hi').then(installed => console.log(installed));
  // async function probeScheme(uri, timeout = 1200) {
  //   return new Promise(resolve => {
  //     const t0 = Date.now();
  //     let done = false;
  //     const onVis = () => {
  //       if (document.hidden) finish(true);
  //     };
  //     function finish(found) {
  //       if (done) return;
  //       done = true;
  //       cleanup();
  //       resolve(found);
  //     }
  //     const timer = setTimeout(()=> {
  //       // if page didn't lose visibility, assume app not installed
  //       finish(false);
  //     }, timeout);
  //     function cleanup() {
  //       clearTimeout(timer);
  //       document.removeEventListener('visibilitychange', onVis);
  //     }
  //     document.addEventListener('visibilitychange', onVis);
  //     // attempt to open:
  //     const iframe = document.createElement('iframe');
  //     iframe.style.display = 'none';
  //     document.body.appendChild(iframe);
  //     try { iframe.src = uri; } catch(e) { finish(false); }
  //     // cleanup iframe in timeout or on finish
  //     setTimeout(() => { iframe.remove(); }, timeout + 500);
  //   });
  // }
}

    </script>
  </body>
</html>
